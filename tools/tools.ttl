# [SC][TODO] ambiguous references to arcpro tools in workflows for "tools:VelocityField" (lines 230 and 235) and "tools:CalculatePartialAmounts" (line 562)

#[SC][TODO] measurement level prefix

@base <https://github.com/quangis/cct/blob/master/tools/tools.ttl#>.

@prefix : <https://github.com/quangis/cct/blob/master/tools/tools.ttl#>.
@prefix cct: <https://github.com/quangis/cct#>.
@prefix wf: <http://geographicknowledge.de/vocab/Workflow.rdf#>.
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>.
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#>.
# @prefix tools: <http://geographicknowledge.de/vocab/GISTools.rdf#>.
@prefix tools: <https://github.com/quangis/cct/blob/master/tools/tools.ttl#>.
@prefix ccd: <http://geographicknowledge.de/vocab/CoreConceptData.rdf#>.
@prefix exm: <http://geographicknowledge.de/vocab/ExtensiveMeasures.rdf#>.

# [SC] tool prefixes
@prefix arcprodm: <https://pro.arcgis.com/en/pro-app/latest/tool-reference/data-management/>.
@prefix arcpro3d: <https://pro.arcgis.com/en/pro-app/latest/tool-reference/3d-analyst/>.
@prefix arcproan: <https://pro.arcgis.com/en/pro-app/latest/tool-reference/analysis/>.
@prefix arcprona: <https://pro.arcgis.com/en/pro-app/latest/tool-reference/network-analyst/>.
@prefix arcprosa: <https://pro.arcgis.com/en/pro-app/latest/tool-reference/spatial-analyst/>.
@prefix arcproco: <https://pro.arcgis.com/en/pro-app/latest/tool-reference/conversion/>.

:Tool a rdfs:Class.

:ToolImplementation rdfs:subClassOf :Tool;
    rdfs:comment "A concrete tool is a reference to a concrete *implementation* of a tool. This is also called a *subtool* sometimes. A tool implementation may operate on more constrained data types than the abstract tool it implements.".

:ToolCombination rdfs:subClassOf :Tool;
    rdfs:comment "A complex abstract tool, a 'supertool': a subworkflow consisting of partial tool specifications that be meaningfully interpreted as a complete tool specification only when taken together. It is composed of tool specifications and implements one or more complete tool specifications.".

:ToolSpecification rdfs:subClassOf :Tool;
    rdfs:comment "An abstract tool refers to the *functionality* of one or more tools.".

:CompleteToolSpecification rdfs:subClassOf :ToolSpecification;
    rdfs:comment "A complete tool specification is a tool specification that is semantically captured with an algebra expression. Every such specification must be implemented by a concrete tool or by a supertool.".

:PartialToolSpecification rdfs:subClassOf :ToolSpecification;
    rdfs:comment "A partial tool specification is a tool specification that has not been semantically captured with an algebra expression. Every such specification must be implemented by a concrete tool.".

:implements a rdfs:Property;
    rdfs:domain :ToolImplementation, :ToolCombination;
    rdfs:range :ToolSpecification.

###Algebra expressions: in the following algebra expressions, x1, x2, x3, etc denote input variables corresponding to wf:input1, wf:input2, wf:input3. Also, the order of inputs in wf:source for supertools corresponds to this order.

### Scenario: Hospitals (hospitalsNetwork.ttl, hospitalsNear.ttl)
### Source: https://pro.arcgis.com/en/pro-app/latest/help/analysis/networks/closest-facility-tutorial.htm
#-------------------------------

##catchment area analysis on spatial network
tools:closestfacilityanalysis a :ToolCombination;
    wf:edge _:wf20_1, _:wf20_2, _:wf20_3, _:wf20_4;
    wf:source _:in_roads, _:in_goals, _:in_origins.
_:wf20_1 wf:applicationOf tools:MakeClosestFacilityAnalysisLayerDef;
    wf:input1 _:in_roads;
    wf:output _:out201.
_:wf20_2 wf:applicationOf tools:AddLocationsDef;
    wf:input1 _:out201;
    wf:input2 _:in_goals;
    wf:output _:out202.
_:wf20_3 wf:applicationOf tools:AddLocationsDef;
    wf:input1 _:out202;
    wf:input2 _:in_origins;
    wf:output _:out203.
_:wf20_4 wf:applicationOf tools:SolveDef;
    wf:input1 _:out203;
    wf:output _:out204.

#selects the distance to the closest goal object on a line network
tools:closestfacilityanalysis a :CompleteToolSpecification;
    wf:input1 _:in_roads;
    wf:input2 _:in_goals;
    wf:input3 _:in_origins; #Events?
    wf:output _:out204;
    rdfs:comment
        "Selects the distance to the closest goal object on a line network.";
    cct:expression
        """
        1: Network(Ratio);
        2: ObjectInfo(Nom);
        3: ObjectInfo(Nom);
        join_attr
            (get_attrL 2)
            (groupbyL min (nDist (get_attrL 2) (get_attrL 3) 1))
        """.
_:in_roads a ccd:NetworkQ, ccd:LineA, ccd:RatioA.
_:in_goals a ccd:ObjectQ, ccd:PointA.
_:in_origins a ccd:ObjectQ, ccd:PointA.
_:out204 a ccd:ObjectQ, ccd:PointA, ccd:RatioA.

#Builds ratio network from line objects
tools:BuildNetwork a :CompleteToolSpecification;
    wf:input1 [ a ccd:ObjectQ, ccd:LineA, ccd:RatioA ];
    wf:output [ a ccd:NetworkQ, ccd:LineA, ccd:RatioA ];
    rdfs:comment
        "Builds ratio network from line objects.";
    cct:expression
        "nbuild (1: ObjectInfo(Ratio))".

#Near tool, to seach for the closest objects using Euclidean distance
tools:NearPointObjects a :CompleteToolSpecification;
    wf:input1 [ a ccd:ObjectQ, ccd:PointA ];
    wf:input2 [ a ccd:ObjectQ, ccd:PointA ];
    wf:output [ a ccd:ObjectQ, ccd:PointA, ccd:RatioA ];
    rdfs:comment
        "Near tool, to seach for the closest objects using Euclidean distance.";
    cct:expression
        """
        1: ObjectInfo(Nom);
        2: ObjectInfo(Nom);
        join_attr
            (get_attrL 1)
            (groupbyL min (oDist (get_attrL 1) (get_attrL 2)))
        """.


### Scenario: Malaria (malaria.ttl)
### Source: https://learn.arcgis.com/en/projects/monitor-malaria-epidemics/
#-------------------------------

#### Object selection variant by id
tools:FC2FCObjectTess a :CompleteToolSpecification;
    wf:input1 [ a ccd:ObjectQ, ccd:VectorTessellationA ];
    wf:output [ a ccd:ObjectQ, ccd:PlainVectorRegionA ];
    rdfs:comment
        "Object selection by id.";
    cct:expression
        """
        subset (1: ObjectInfo(Nom)) (-: C(Obj))
        """.

##Merge object parts into single object
tools:MergeObjects a :CompleteToolSpecification;
    wf:input1 [ a ccd:ObjectQ, ccd:VectorTessellationA, ccd:NominalA ];
    wf:output [ a ccd:ObjectQ, ccd:VectorTessellationA , ccd:NominalA ];
    rdfs:comment
        "Merges object parts into single objects based on object identifiers stored as names.";
    cct:expression
        """
        1: ObjectInfo(Nom);
        join_attr
            (groupby
                (compose merge (compose pi2 (subset (get_attrL 1))))
                (apply1 objectify (get_attrR 1))
            )
            (getobjectnames (pi2 (get_attrR 1)))
        """.

##Make table from excel
tools:JoinFromTable a :ToolCombination;
    tools:implements tools:LoadAmountonObjects;
    wf:edge _:wf10_1, _:wf10_2;
    wf:source _:in10_1, _:in10_2.
_:wf10_1  wf:applicationOf tools:ExcelToTableDef;
    wf:input1 _:in10_1;
    wf:output _:out10.
_:wf10_2  wf:applicationOf tools:JoinFieldDef;
    wf:input1 _:in10_2;
    wf:input2 _:out10;
    wf:output _:out10_2.

tools:LoadAmountonObjects a :CompleteToolSpecification;
    wf:input1 _:in10_1;
    wf:input2 _:in10_2;
    wf:output _:out10_2;
    rdfs:comment
        "Loads object based count amounts from excel and joins them with vector objects.";
    cct:expression
        """
        1: R2(Obj, Count);
        2: ObjectInfo(_);
        join_attr (get_attrL 2) 1
        """.
_:in10_1 a ccd:ObjectQ, ccd:CountA.
_:in10_2 a ccd:ObjectQ, ccd:VectorRegionA.
_:out10_2 a ccd:ObjectQ, ccd:VectorRegionA, ccd:CountA.



### Scenario: PredictFloods (Floods.ttl)
### Source: https://learn.arcgis.com/en/projects/predict-floods-with-unit-hydrographs/
#-------------------------------

# 1: generate flow velocity raster from flow accumulation (sum of area upstream) and slope.

# 2: con and con : constrain velocity raster to min and max velocity. Then invert velocity (to get a weight). Then estimate flow length (time) to the outflow point for each raster cell based on velocity weight and direction raster.

# 3: reclassify time into intervals to get isochrone raster.  Summary table and convert area per 30 minutes to area per second. unit hydrograph: drainage area per second.

#Flow direction raster
tools:FlowDirection a :CompleteToolSpecification;
    wf:input1 [ a ccd:FieldRaster, ccd:IntervalA ]; ## DEM
    wf:output [ a ccd:FieldRaster, ccd:CyclicA ];
    rdfs:comment
        "Computes a grid graph of flow directions from a DEM.";
    cct:expression
        "flowdirgraph (1: Field(Itv))".

#Flow direction accumulation
tools:FlowAccumulation a :CompleteToolSpecification;
    wf:input1 [ a ccd:FieldRaster, ccd:CyclicA ]; ##needs to be a direction
    wf:output [ a ccd:FieldRaster, ccd:RatioA ];
    rdfs:comment
        "Accumulates flow directions into areas reachable downstream.";
    cct:expression
        "apply1 size (accumulate (1: Field(Loc)))".

#Slope computation
tools:Slope a :CompleteToolSpecification;
    wf:input1 [ a ccd:FieldRaster, ccd:IntervalA ]; ## DEM
    wf:output [ a ccd:FieldRaster, ccd:RatioA ];
    rdfs:comment
        "Computes slopes of a DEM.";
    cct:expression
        "slope (1: Field(Itv))".

#Method for flow velocities
tools:VelocityField a :ToolCombination;
    tools:implements tools:VelocityFieldDEM;
    wf:edge _:wf44_4, _:wf44_5;
    wf:source _:slope, _:acc;
    rdfs:comment "Computes a water flow velocity raster from slope * accumulation area".
#### Select by attribute is always followed by copying features
    #This computes SquareRoot("slope") * SquareRoot("flow_accumulation")
_:wf44_4 wf:applicationOf tools:RasterCalculatorDef;
    wf:input1 _:slope;
    wf:input2 _:acc;
    wf:output _:slopearea.
    #This second step computes 0.1 * ("Stowe_slope_area_term" / [Mean slope-area term]). It needs looking up of parameter [Mean slope-area term].
_:wf44_5 wf:applicationOf tools:RasterCalculator1Def;
    wf:input1 _:slopearea;
    wf:output _:velocity.

tools:VelocityFieldDEM a :ToolCombination;
    wf:input1 _:slope; ##  slope
    wf:input2 _:acc; ##  accumulation area
    wf:output _:velocity;
    rdfs:comment
        "Computes velocity field from DEM.";
    cct:expression
        "apply2 product (1: Field(Ratio)) (2: Field(Ratio))".
_:slope a ccd:FieldRaster, ccd:RatioA.
_:acc a ccd:FieldRaster, ccd:RatioA.
_:velocity a ccd:FieldRaster, ccd:RatioA.

#Con with leq/gte
tools:con1 a :CompleteToolSpecification;
    wf:input1 [ a ccd:FieldRaster, ccd:RatioA ]; ## raster
    wf:output [ a ccd:FieldRaster, ccd:RatioA ];
    rdfs:comment
        "Cuts a field raster conditional on less than some value";
    cct:expression
        "select leq (1: Field(Ratio)) (-: Ratio)".

### local map algebra transformation invert
tools:LocalMapAlgebraInvert a :CompleteToolSpecification;
    wf:input1 [ a ccd:FieldRaster, ccd:RatioA ];
    wf:output [ a ccd:FieldRaster, ccd:RatioA ];
    rdfs:comment
        "Builds and executes a Local Map Algebra expression that inverts rasters with a ratio level.";
    cct:expression
        "apply1 (ratio (-: Ratio)) (1: Field(Ratio))".

#Snap point to raster
tools:SnapPourPoint a :CompleteToolSpecification;
    wf:input1 [ a ccd:ObjectQ, ccd:PointA ]; #Snap pour point to river (Distance: 60m)
    wf:input2 [ a ccd:FieldRaster, ccd:RatioA ]; # flow accumulation raster
    wf:output [ a ccd:FieldQ, ccd:RasterA, ccd:PlainNominalA ];
    rdfs:comment
        "Snaps a pour point to a raster to generate a raster showing the pour point.";
    cct:expression
        # This is a simplification that ignores flow accumulation, but just
        # generates a nominal patch from an object nominal
        """
        1: ObjectInfo(Nom);
        join (revert (get_attrL 1)) (get_attrR 1)
        """.

tools:Watershed a :CompleteToolSpecification;
    wf:input1 [ a ccd:FieldRaster, ccd:RatioA ]; #flow direction raster
    wf:input2 [ a ccd:FieldQ, ccd:RasterA, ccd:PlainNominalA ]; # pour point raster
    wf:output [ a ccd:FieldQ, ccd:RasterA, ccd:PlainNominalA ]; #watershed raster, gives a different watershed id for each pour point
    rdfs:comment
        "Given a flow direction raster and a pour point raster, generates a watershed raster.";
    cct:expression
        """
        revert (join
            (invert (2: Field(Nom)))
            (invert (apply1 reify (accumulate (1: Field(Loc)))))
        )
        """.

tools:ExtractByMask a :CompleteToolSpecification;
    wf:input1 [ a ccd:FieldRaster, ccd:RatioA ]; #Flow directions by watershed mask
    wf:input2 [ a ccd:FieldRaster ];
    wf:output [ a ccd:FieldRaster, ccd:RatioA ];
    rdfs:comment
        "Extract raster by the extent of another (field) raster.";
    cct:expression
        "subset (1: Field(Loc)) (pi1 (2: Field(Nom)))".

tools:FlowLength a :CompleteToolSpecification;
    wf:input1 [ a ccd:FieldRaster, ccd:RatioA ]; #Impedance Weight raster (e.g. 1/velocity raster)
    wf:input2 [ a ccd:FieldRaster, ccd:RatioA ]; #Flow direction raster;
    wf:output [ a ccd:FieldRaster, ccd:RatioA ]; #Flow time raster.
    rdfs:comment
        "Calculate the upstream or downstream distance, or weighted distance (=time), along the flow path for each cell.";
    cct:expression
        """
        1: Field(Ratio);
        2: Field(Loc);
        groupbyL max (relunion (pi2 (apply2
            (lgDist (gridgraph 2 1))
            (apply nest (pi1 2)) (accumulate 2)
        )))
        """.

tools:RasterToIsoRaster a :CompleteToolSpecification;
    wf:input1 [ a ccd:FieldRaster, ccd:IntervalA ];
    wf:output [ a ccd:FieldRaster, ccd:PlainOrdinalA ];
    rdfs:comment
        "Converts an interval field raster into an ordinal raster.";
    cct:expression
        "apply1 classify (1: Field(Itv))".

#Method for summarizing raster coverages
tools:RasterCoverage a :ToolCombination;
    tools:implements tools:CreateUnitHydrograph;
    wf:edge _:wf55_1, _:wf55_2, _:wf55_3;
    wf:source _:fieldraster;
    rdfs:comment "Computes coverage (size) from a raster table for each raster value".
_:wf55_1 wf:applicationOf tools:TableToTableDef;
    wf:input1 _:fieldraster;
    wf:output _:rastertable.
_:wf55_2 wf:applicationOf tools:AddFieldDef;
    wf:input1 _:rastertable;
    wf:output _:rastertable2.
_:wf55_3 wf:applicationOf tools:CalculateFieldDef;
    wf:input1 _:rastertable2;
    wf:output _:rastertable3.

tools:CreateUnitHydrograph a :CompleteToolSpecification;
    wf:input1 _:fieldraster; ##
    wf:output _:rastertable3;
    rdfs:comment
        "Creates a unit hydrograph from an isochrones raster based on isochrone interval. This is a table that indicates for each time interval an areal coverage";
    cct:expression
        """
        apply1 ((swap ratio) (-: Ratio)) (groupby size (1: Field(Ord)))
        """.
_:fieldraster a ccd:FieldRaster, ccd:OrdinalA.
_:rastertable3 a ccd:AmountQ, ccd:LayerA, ccd:RatioA.


### Scenario: AquiferDepletion (aquifer.ttl)
### Source: https://learn.arcgis.com/en/projects/find-areas-at-risk-from-aquifer-depletion/
#-------------------------------

#### Select features
tools:FullSelectFeatures a :ToolCombination;
    tools:implements 
        tools:SelectFeaturesByObjectPlainRegionObjects, 
        tools:SelectFeaturesCoverageToExistenceVector;
    wf:edge _:wf111_1, _:wf111_2;
    wf:source _:in111;
    rdfs:comment "Query to select items from layers using attribut values".
#### Select by attribute is always followed by copying features
_:wf111_1 wf:applicationOf tools:SelectLayerByAttributeDef;
    wf:input1 _:in111;
    wf:output _:out111.
_:wf111_2 wf:applicationOf tools:FC2FCObjectTess;
    wf:input1 _:out111;
    wf:output _:out112.

tools:SelectFeaturesByObjectPlainRegionObjects a :CompleteToolSpecification;
    wf:input1 _:in111_1; ##
    wf:output _:out112_1;
    rdfs:comment
        "Select region objects by id";
    cct:expression
        "subset (1: ObjectInfo(Nom)) (-: C(Obj))".
_:in111_1 
    wf:proxyFor _:in111;
    a ccd:ObjectQ, ccd:PlainVectorRegionA.
_:out112_1 
    wf:proxyFor _:out112;
    a ccd:ObjectQ, ccd:PlainVectorRegionA.

tools:SelectFeaturesCoverageToExistenceVector a :CompleteToolSpecification;
    wf:input1 _:in111_2;
    wf:output _:out112_2;
    rdfs:comment
        "Select patches of a coverage by attribute";
    cct:expression
        "revert (select eq (invert (1: Field(Itv)): Coverages(Nom)) (-: Nom))".
_:in111_2 
    wf:proxyFor _:in111;
    a ccd:Coverage.
_:out112_2 
    wf:proxyFor _:out112;
    a ccd:FieldQ, ccd:PlainVectorRegionA.



### Scenario:  SolarPowerPotential (solar.ttl)
### Source: https://learn.arcgis.com/en/projects/estimate-solar-power-potential/
#-------------------------------

tools:Aspect a :CompleteToolSpecification;
    wf:input1 [ a ccd:FieldRaster, ccd:IntervalA ]; ##
    wf:output [ a ccd:FieldRaster, ccd:RatioA ];
    rdfs:comment
        "Derives the aspect of a digital elevation model";
    cct:expression
        "aspect (1: Field(Itv))".

### local map algebra divide
tools:LocalMapAlgebraDivide a :CompleteToolSpecification;
    wf:input1 [ a ccd:FieldRaster, ccd:RatioA ];
    wf:output [ a ccd:FieldRaster, ccd:RatioA ];
    rdfs:comment
        "Builds and executes a Local Map Algebra expression that divides rasters by a ratio number";
    cct:expression
        "apply1 ((swap ratio) (-: Ratio)) (1: Field(Ratio))".

tools:con2 a :CompleteToolSpecification;
    wf:input1 [ a ccd:FieldRaster, ccd:RatioA ]; ## conditional raster, less than some value
    wf:input2 [ a ccd:FieldRaster, ccd:RatioA ]; ## field raster to be cut
    wf:output [ a ccd:FieldRaster, ccd:RatioA ];
    rdfs:comment
        "Cuts a field raster conditional on (the coverage of) another field raster that is less than some value";
    cct:expression
        "subset (2: Field(Ratio)) (pi1 (select leq (1: Field(Ratio)) (-: Ratio)))".

tools:con3 a :CompleteToolSpecification;
    wf:input1 [ a ccd:FieldRaster, ccd:RatioA ]; ## conditional raster, less than some value
    wf:input2 [ a ccd:FieldRaster, ccd:RatioA ]; ## field raster to be cut for inside
    wf:input3 [ a ccd:FieldRaster, ccd:RatioA ]; ## field raster to be cut for outside
    wf:output [ a ccd:FieldRaster, ccd:RatioA ];
    rdfs:comment
        "Cuts a field raster conditional on (the coverage of) another field raster, and adds another field raster for those locations outside of the coverage";
    cct:expression
        """
        1: Field(Ratio);
        2: Field(Ratio);
        3: Field(Ratio);
        set_union
            (subset 2 (pi1 (select leq 1 (-: Ratio))))
            (subset 3 (pi1 (select eq (lTopo
                (pi1 3)
                (reify (pi1 (select leq 1 (-: Ratio))))
            ) out)))
        """.

tools:AddandCalculateAttribute a :ToolCombination;
    tools:implements 
        tools:CalculateObjectSpatialAmount, 
        tools:CalculateProd, 
        tools:CalculateProdPointObjects;
    wf:edge _:wf300_1, _:wf300_2;
    wf:source _:in3001;
    rdfs:comment "Add an attribute and calculate value based on one other attribute".
_:wf300_1 wf:applicationOf tools:AddFieldDef;
    wf:input1 _:in3001;
    wf:output _:out3001.
_:wf300_2 wf:applicationOf tools:CalculateFieldDef;
    wf:input1 _:out3001;
    wf:output _:out300.

##Uses calculate field to obtain an extensive amount on objects from an average
tools:CalculateObjectSpatialAmount a :ToolCombination;
    wf:input1 _:in3001_1;
    wf:output _:out300_1;
    rdfs:comment
        "Calculates an amount from an object ratio quality (representating an intensive measure) using the object's area. For example, the amount of radiation falling on a building using the mean radiation and the building's area";
    cct:expression
        """
        1: ObjectInfo(Ratio);
        join_attr
            (get_attrL 1)
            (apply2 product
                (get_attrR 1)
                (apply1 (compose size deify) (get_attrL 1))
            )
        """.
_:in3001_1
    wf:proxyFor _:in3001;
    a ccd:ObjectQ, ccd:VectorRegionA, exm:IRA.
_:out300_1
    wf:proxyFor _:out300;
    a ccd:ObjectQ, ccd:VectorRegionA, exm:ERA.

tools:CalculateProd a :CompleteToolSpecification;
    wf:input1 _:in3001_2;
    wf:output _:out300_2;
    rdfs:comment
        "Calculates some product of ratio scaled object attribute with some ratio value.";
    cct:expression
        """
        1: ObjectInfo(Ratio);
        join_attr
            (get_attrL 1)
            (apply1 (product (-: Ratio)) (get_attrR 1))
        """.
_:in3001_2
    wf:proxyFor _:in3001;
    a ccd:ObjectQ, ccd:VectorRegionA, ccd:RatioA.
_:out300_2
    wf:proxyFor _:out300;
    a ccd:ObjectQ, ccd:VectorRegionA, ccd:RatioA.

tools:CalculateProdPointObjects a :CompleteToolSpecification;
    wf:input1 _:in3001_3;
    wf:output _:out300_3;
    rdfs:comment
        "Calculates a product from an attribute using some constant (e.g. time from distance using speed constant)";
    cct:expression
        """
        1: ObjectInfo(Ratio);
        join_attr
            (get_attrL 1)
            (apply1 (product (-: Ratio)) (get_attrR 1))
        """.
_:in3001_3
    wf:proxyFor _:in3001;
    a ccd:ObjectQ, ccd:PointA, exm:ERA.
_:out300_3
    wf:proxyFor _:out300;
    a ccd:ObjectQ, ccd:PointA, exm:ERA.


### Scenario: InfrastructureAccess (InfrastructureAccess.ttl)
### Source: https://learn.arcgis.com/en/projects/estimate-access-to-infrastructure/
#-------------------------------


##Summary statistics for amounts
tools:ObjectSummaryStatisticsAmount a :CompleteToolSpecification;
    wf:input1 [ a ccd:ObjectQ, ccd:VectorRegionA, ccd:CountA ]; ##
    wf:output [ a ccd:AmountQ, ccd:VectorRegionA, ccd:CountA ];
    rdfs:comment
        "Sums the amount values of an object layer into a sum";
    cct:expression
        "contentsum (getamounts (1: ObjectInfo(Ratio)))".

tools:SummaryStatisticsAmount a :CompleteToolSpecification;
    wf:input1 [ a ccd:AmountQ, ccd:VectorRegionA, ccd:CountA ]; ##
    wf:output [ a ccd:AmountQ, ccd:VectorRegionA, ccd:CountA ];
    rdfs:comment
        "Sums the amount values of a count amount layer into a sum";
    cct:expression
        "contentsum (1: Amounts(Ratio))".

tools:ClipObject2Object a :CompleteToolSpecification;
    wf:input1 [ a ccd:ObjectQ, ccd:PlainVectorRegionA, ccd:CountA ]; ## objects to be clipped
    wf:input2 [ a ccd:ObjectQ, ccd:PlainVectorRegionA ]; ##to the regions of these objects
    wf:output [ a ccd:ObjectQ, ccd:PlainVectorRegionA, ccd:CountA ];
    rdfs:comment
        "Clips some object polygons to the extent of an object layer. We assume here that objects exactly coincide (otherwise clip would cut objects).";
    cct:expression
        """
        1: ObjectInfo(Count);
        2: ObjectInfo(Nom);
        subset
            1
            (pi1 (select eq
                (oTopo (get_attrL 1) (get_attrL 2))
                in
            ))
        """.

tools:CalculatePartialAmounts a :ToolCombination;
    tools:implements tools:CalculatePartialAmountsfromObjects;
    wf:edge _:wf01_0, _:wf01_1, _:wf01_2, _:wf01_3;
    wf:source _:in011, _:in012.
_:wf01_0 wf:applicationOf tools:ClipDef;
    wf:input1 _:in011;
    wf:input2 _:in012;
    wf:output _:out011.
_:wf01_1 wf:applicationOf tools:AddFieldsDef;
    wf:input1 _:out011;
    wf:output _:out012.
_:wf01_2 wf:applicationOf tools:CalculateFieldDef;
    wf:input1 _:out012;
    wf:output _:out013.
_:wf01_3 wf:applicationOf tools:CalculateFieldDef;
    wf:input1 _:out013;
    wf:output _:out014.

##CalculatePartialAmounts: Calculates a set of portions from a set of object based count amounts using some boolean vector field. Only the portions that are within the true value of the boolean field are considered. This is an areal interpolation problem, which is solved by first generating area proportions and then multiplying them with the count amount.
tools:CalculatePartialAmountsfromObjects a :CompleteToolSpecification;
    wf:input1 _:in011;
    wf:input2 _:in012;
    wf:output _:out014;
    rdfs:comment
        "Clips some object vector with some count amounts to the extent of a field layer (e.g. a buffer) and interpolates partial count amounts R(Reg, Ratio) based on area percentage.";
    cct:expression
        """
        1: ObjectInfo(Count);
        2: Field(Bool);
        arealinterpol
            (getamounts 1)
            (pi2 (groupbyR reify (select eq (loTopo
                (fcover 2 (nest true))
                (get_attrL 1)
            ) in)))
        """.
_:in011 a ccd:ObjectQ, ccd:VectorRegionA, ccd:CountA.
_:in012 a ccd:FieldQ, ccd:VectorRegionA, ccd:BooleanA.
_:out014 a ccd:AmountQ, ccd:VectorRegionA, ccd:CountA.
 

### Scenario: Deforestation (deforestation.ttl)
### Source: https://learn.arcgis.com/en/projects/predict-deforestation-in-the-amazon-rain-forest/
#-------------------------------

##Select object by extent
tools:SelectObjectbyExtent a :CompleteToolSpecification;
    wf:input1 [ a ccd:ObjectQ, ccd:VectorA ];
    wf:output [ a ccd:ObjectQ, ccd:VectorA ];
    rdfs:comment
        "Select object vector by extent. Extent remains implicit.";
    cct:expression
        """
        1: ObjectInfo(Nom);
        subset 1 (pi3 (select
            eq
            (loTopo (deify (-: Reg)) (get_attrL 1))
            in
        ))
        """.

##Buffer (interpreted as vector representation of boolean field)
tools:ObjectBuffer a :CompleteToolSpecification;
    wf:input1 [ a ccd:ObjectQ, ccd:VectorA ];
    wf:output [ a ccd:FieldQ, ccd:PlainVectorRegionA, ccd:BooleanA ];
    rdfs:comment
        "Buffers some object vector and returns the buffer as a boolean field R(Loc, Bool)";
    cct:expression
        "extrapol (get_attrL (1: ObjectInfo(Nom)))".

##Clip vector fields
tools:ClipNomFieldVector2Extent a :CompleteToolSpecification;
    wf:input1 [ a ccd:FieldQ, ccd:VectorRegionA ];
    wf:input2 [ a ccd:FieldQ, ccd:VectorRegionA, ccd:BooleanA ];
    wf:output [ a ccd:FieldQ, ccd:VectorRegionA ];
    rdfs:comment
        "Clips some nominal field vector to the region where a boolean field vector is true.";
    cct:expression
        "subset (1: Field(Nom)) (fcover (2: Field(Bool)) (nest true))".

tools:ClipBoolFieldVector2Extent a :CompleteToolSpecification;
    wf:input1 [ a ccd:FieldQ, ccd:VectorRegionA, ccd:BooleanA];
    wf:input2 [ a ccd:FieldQ, ccd:VectorRegionA, ccd:BooleanA ];
    wf:output [ a ccd:FieldQ, ccd:VectorRegionA, ccd:BooleanA ];
    rdfs:comment
        "Clips some boolean field vector to the region where a boolean field vector is true.";
    cct:expression
        "subset (1: Field(Bool)) (fcover (2: Field(Bool)) (nest true))".



##CalculateAreaMeasure: This is an abbreviated workflow for calculating area based measures with attributes
tools:CalculateAreaMeasure a :ToolCombination;
    tools:implements 
        tools:CalculateVectorFieldAreaPercentage, 
        tools:CalculateVectorFieldPartialArea, 
        tools:CalculateCountAmountRatio, 
        tools:CalculateObjectVectorCountAmountRatio, 
        tools:CalculateObjectAttrRatio;
    wf:edge _:wf11_1, _:wf11_2;
    wf:source _:in1111, _:in1112.
_:wf11_1 wf:applicationOf tools:AddFieldDef;
    wf:input1 _:in1111;
    wf:output _:out1111.
_:wf11_2 wf:applicationOf tools:CalculateField2Def;
    wf:input1 _:out1111;
    wf:input2 _:in1112;
    wf:output _:out1112.

##The assumption is here is that fields are represented by single polygons and area measures are implicitly added. The area measure of the second layer is manually taken over into the calculation. The result is a single measure, though stored into a table with a single polygon.

#Substance Coverage proportions SC/SC
tools:CalculateVectorFieldAreaPercentage a :CompleteToolSpecification;
    wf:input1 _:in1111_1;
    wf:input2 _:in1112_1;
    wf:output _:out1112_1;
    rdfs:comment
        "Calculates an area ratio (amount) of the size of the extent of the second boolean field with respect to the extent of the first boolean field, both represented by vector layers.";
    cct:expression
        """
        nest2 true (ratio
            (size (fcover (1: Field(Bool)) (nest true)))
            (size (fcover (2: Field(Bool)) (nest true)))
        )
        """.
_:in1111_1
    wf:proxyFor _:in1111;
    a ccd:FieldQ, ccd:VectorRegionA, ccd:BooleanA.
_:in1112_1
    wf:proxyFor _:in1112;
    a ccd:FieldQ, ccd:VectorRegionA, ccd:BooleanA.
_:out1112_1
    wf:proxyFor _:out1112;
    a ccd:AmountQ, ccd:VectorRegionA, exm:IRA.

#Substance Coverage SC
tools:CalculateVectorFieldPartialArea a :CompleteToolSpecification;
    wf:input1 _:in1111_2; #field whose extent is interpreted as a Substance Coverage SC
    wf:input2 _:in1112_2;#Substance Coverage proportion SC/SC
    wf:output _:out1112_2;
    rdfs:comment
        "Calculates a partial area measure by multiplying an area proportion with the size of the extent of a vector field.";
    cct:expression
        "apply1 (product (size (pi1 (1: Field(Nom))))) (2: R2(Bool, Ratio))".
_:in1111_2
    wf:proxyFor _:in1111;
    a ccd:FieldQ, ccd:VectorRegionA.
_:in1112_2
    wf:proxyFor _:in1112;
    a ccd:AmountQ, ccd:VectorRegionA, exm:IRA.
_:out1112_2
    wf:proxyFor _:out1112;
    a ccd:AmountQ, ccd:VectorRegionA, exm:ERA.

#Object Content proportion OA/OA
tools:CalculateCountAmountRatio a :CompleteToolSpecification;
    wf:input1 _:in1111_3;
    wf:input2 _:in1112_3;
    wf:output _:out1112_3;
    rdfs:comment
        "Calculates the ratio of two count vector amounts.";
    cct:expression
        "apply2 ratio (1: Amounts(Ratio)) (2: Amounts(Ratio))".
_:in1111_3
    wf:proxyFor _:in1111;
    a ccd:AmountQ, ccd:VectorRegionA, ccd:CountA.
_:in1112_3
    wf:proxyFor _:in1112;
    a ccd:AmountQ, ccd:VectorRegionA, ccd:CountA.
_:out1112_3
    wf:proxyFor _:out1112;
    a ccd:AmountQ, ccd:VectorRegionA, exm:IRA.

#Calculate new attribute: Object Content proportion OA/OA
tools:CalculateObjectVectorCountAmountRatio a :CompleteToolSpecification;
    wf:input1 _:in1111_4;
    wf:input2 _:in1112_4;
    wf:output _:out1112_4;
    rdfs:comment
        "Calculates the ratio of two count vector amounts on objects.";
    cct:expression
        """
        1: ObjectInfo(Count);
        2: ObjectInfo(Count);
        join_attr
            (get_attrL 1)
            (apply2 ratio (get_attrR 1) (get_attrR 2))
        """.
_:in1111_4
    wf:proxyFor _:in1111;
    a ccd:ObjectQ, ccd:VectorRegionA, ccd:CountA.
_:in1112_4
    wf:proxyFor _:in1112;
    a ccd:ObjectQ, ccd:VectorRegionA, ccd:CountA.
_:out1112_4
    wf:proxyFor _:out1112;
    a ccd:ObjectQ, ccd:VectorRegionA, exm:IRA.

#<https://pro.arcgis.com/en/pro-app/tool-reference/data-management/calculate-field.htm>
tools:CalculateObjectAttrRatio a :CompleteToolSpecification;
    wf:input1 _:in1111_5;
    wf:input2 _:in1112_5;
    wf:output _:out1112_5;
    rdfs:comment
        "Calculates ratios of two ratio scaled object attributes.";
    cct:expression
        """
        1: ObjectInfo(Ratio);
        2: ObjectInfo(Ratio);
        join_attr
            (get_attrL 1)
            (apply2 ratio (get_attrR 1) (get_attrR 2))
        """.
_:in1111_5
    wf:proxyFor _:in1111;
    a ccd:ObjectQ, ccd:VectorRegionA, exm:ERA.
_:in1112_5
    wf:proxyFor _:in1112;
    a ccd:ObjectQ, ccd:VectorRegionA, exm:ERA.
_:out1112_5
    wf:proxyFor _:out1112;
    a ccd:ObjectQ, ccd:VectorRegionA, exm:IRA.



##Erase Vector fields
tools:EraseFieldExtentfromFieldVector a :CompleteToolSpecification;
    wf:input1 [ a ccd:FieldQ,  ccd:PlainVectorRegionA ];
    wf:input2 [ a ccd:FieldQ, ccd:VectorRegionA, ccd:BooleanA ];
    wf:output [ a ccd:FieldQ,  ccd:PlainVectorRegionA];
    rdfs:comment
        "Erases the coverage of a boolean field vector (second input) from a field vector (first input)";
    cct:expression
        """
        1: Field(Nom);
        2: Field(Bool);
        subset
            1
            (pi1 (select
                eq
                (lTopo (pi1 1) (reify (fcover 2 (nest true))))
                out
            ))
        """.


### Scenario: Population (AmountsObjectsUtrecht.ttl)
### Source: own
#-------------------------------

#### Select layer by attribute
tools:FullSelectLayerByAttribute a :ToolCombination;
    tools:implements 
        tools:SelectLayerByObjectPointObjects, 
        tools:SelectLayerByObjectLineObjects, 
        tools:SelectLayerByObjectPlainRegionObjects,
        tools:SelectLayerByObjectTessObjects,
        tools:SelectLayerByAttributePointObjects, 
        tools:SelectLayerByAttributeLineObjects, 
        tools:SelectLayerByAttributePlainRegionObjects,
        tools:SelectLayerByAttributeTessObjects, 
        tools:SelectLayerByRatioPointObjects, 
        tools:SelectLayerByRatioLineObjects, 
        tools:SelectLayerByRatioPlainRegionObjects,
        tools:SelectLayerByRatioTessObjects,
        tools:SelectLayerContourToExistenceVector,
        tools:SelectLayerByRatioGEQPlainRegionObjects,
        tools:SelectLayerCoverageToExistenceVector;
    wf:edge _:wf1_1, _:wf1_2;
    wf:source _:in11;
    rdfs:comment "a SQL query to select features matching a selection criterion. You build a query expression to generate the subset. You can query a dataset based on a field in a layer or a table. Using this selection a new Feature dataset is created with only the selected features using the 'Copy Features tool'. This feature dataset represents all the areas that fulfill the criterion".
#### Select by attribute is always followed by copy features (treated as one tool in the annotation
_:wf1_1 wf:applicationOf tools:SelectLayerByAttributeDef;
    wf:input1 _:in11;
    wf:output _:out11.
_:wf1_2 wf:applicationOf tools:CopyFeaturesDef;
    wf:input1 _:out11;
    wf:output _:out12.

#### Object selection variant by id
tools:SelectLayerByObjectPointObjects a :CompleteToolSpecification;
    wf:input1 _:in11_1;
    wf:output _:out12_1;
    cct:expression
        "subset (objectregionnominals x1) (objects)".
_:in11_1
    wf:proxyFor _:in11;
    a ccd:ObjectQ, ccd:PointA.
_:out12_1
    wf:proxyFor _:out12;
    a ccd:ObjectQ, ccd:PointA, ccd:BooleanA.

#### Object selection variant by id
tools:SelectLayerByObjectLineObjects a :CompleteToolSpecification;
    wf:input1 _:in11_2;
    wf:output _:out12_2;
    cct:expression
        "subset (1: ObjectInfo(Nom)) (-: C(Obj))".
_:in11_2
    wf:proxyFor _:in11;
    a ccd:ObjectQ, ccd:LineA.
_:out12_2
    wf:proxyFor _:out12;
    a ccd:ObjectQ, ccd:LineA, ccd:BooleanA.

#### Object selection variant by id
tools:SelectLayerByObjectPlainRegionObjects a :CompleteToolSpecification;
    wf:input1 _:in11_3;
    wf:output _:out12_3;
    cct:expression
        "subset (1: ObjectInfo(Nom)) (-: C(Obj))".
_:in11_3
    wf:proxyFor _:in11;
    a ccd:ObjectQ, ccd:PlainVectorRegionA.
_:out12_3
    wf:proxyFor _:out12;
    a ccd:ObjectQ, ccd:PlainVectorRegionA, ccd:BooleanA.

#### Object selection variant by id
tools:SelectLayerByObjectTessObjects a :CompleteToolSpecification;
    wf:input1 _:in11_4;
    wf:output _:out12_4;
    cct:expression
        "subset (1: ObjectInfo(Nom)) (-: C(Obj))".
_:in11_4
    wf:proxyFor _:in11;
    a ccd:ObjectQ, ccd:VectorTessellationA.
_:out12_4
    wf:proxyFor _:out12;
    a ccd:ObjectQ, ccd:PlainVectorRegionA, ccd:BooleanA.

#### Object selection variant, needs a nominal attribute
tools:SelectLayerByAttributePointObjects a :CompleteToolSpecification;
    wf:input1 _:in11_5;
    wf:output _:out12_5;
    cct:expression
        "subset (1: ObjectInfo(Nom)) (-: C(Nom))".
_:in11_5
    wf:proxyFor _:in11;
    a ccd:ObjectQ, ccd:PointA, ccd:NominalA.
_:out12_5
    wf:proxyFor _:out12;
   a ccd:ObjectQ, ccd:PointA, ccd:NominalA.

#### Object selection variant, needs a nominal attribute
tools:SelectLayerByAttributeLineObjects a :CompleteToolSpecification;
    wf:input1 _:in11_6;
    wf:output _:out12_6;
    cct:expression
        "subset (1: ObjectInfo(Nom)) (-: C(Nom))".
_:in11_6
    wf:proxyFor _:in11;
    a ccd:ObjectQ, ccd:LineA, ccd:NominalA.
_:out12_6
    wf:proxyFor _:out12;
    a ccd:ObjectQ, ccd:LineA, ccd:NominalA.

#### Object selection variant, needs a nominal attribute
tools:SelectLayerByAttributePlainRegionObjects a :CompleteToolSpecification;
    wf:input1 _:in11_7;
    wf:output _:out12_7;
    cct:expression
        "subset (1: ObjectInfo(Nom)) (-: C(Nom))".
_:in11_7
    wf:proxyFor _:in11;
    a ccd:ObjectQ, ccd:PlainVectorRegionA, ccd:NominalA.
_:out12_7
    wf:proxyFor _:out12;
    a ccd:ObjectQ, ccd:PlainVectorRegionA, ccd:NominalA.

#### Object selection variant, needs a nominal attribute
tools:SelectLayerByAttributeTessObjects a :CompleteToolSpecification;
    wf:input1 _:in11_8;
    wf:output _:out12_8;
    cct:expression
        "subset (1: ObjectInfo(Nom)) (-: C(Nom))".
_:in11_8
    wf:proxyFor _:in11;
    a ccd:ObjectQ, ccd:VectorTessellationA, ccd:NominalA.
_:out12_8
    wf:proxyFor _:out12;
    a ccd:ObjectQ, ccd:PlainVectorRegionA, ccd:NominalA.

#### Object selection variant, needs a ratio attribute
tools:SelectLayerByRatioPointObjects a :CompleteToolSpecification;
    wf:input1 _:in11_9;
    wf:output _:out12_9;
    cct:expression
        "subset (1: ObjectInfo(Ratio)) (-: C(Ratio))".
_:in11_9
    wf:proxyFor _:in11;
    a ccd:ObjectQ, ccd:PointA, ccd:RatioA.
_:out12_9
    wf:proxyFor _:out12;
    a ccd:ObjectQ, ccd:PointA, ccd:RatioA.

#### Object selection variant, needs a ratio attribute
tools:SelectLayerByRatioLineObjects a :CompleteToolSpecification;
    wf:input1 _:in11_10;
    wf:output _:out12_10;
    cct:expression
        "subset (1: ObjectInfo(Ratio)) (-: C(Ratio))".
_:in11_10
    wf:proxyFor _:in11;
    a ccd:ObjectQ, ccd:LineA, ccd:RatioA.
_:out12_10
    wf:proxyFor _:out12;
    a ccd:ObjectQ, ccd:LineA, ccd:RatioA.

#### Object selection variant, needs a ratio attribute
tools:SelectLayerByRatioPlainRegionObjects a :CompleteToolSpecification;
    wf:input1 _:in11_11;
    wf:output _:out12_11;
    cct:expression
        "subset (1: ObjectInfo(Ratio)) (-: C(Ratio))".
_:in11_11
    wf:proxyFor _:in11;
    a ccd:ObjectQ, ccd:PlainVectorRegionA, ccd:RatioA.
_:out12_11
    wf:proxyFor _:out12;
    a ccd:ObjectQ, ccd:PlainVectorRegionA, ccd:RatioA.

#### Object selection variant, needs a ratio attribute
tools:SelectLayerByRatioTessObjects a :CompleteToolSpecification;
    wf:input1 _:in11_12;
    wf:output _:out12_12;
    cct:expression
        "subset (1: ObjectInfo(Ratio)) (-: C(Ratio))".
_:in11_12
    wf:proxyFor _:in11;
    a ccd:ObjectQ, ccd:VectorTessellationA, ccd:RatioA.
_:out12_12
    wf:proxyFor _:out12;
    a ccd:ObjectQ, ccd:PlainVectorRegionA, ccd:RatioA.

#### Contour to Existence Vector (select a contour map greater than some ordinal value)
tools:SelectLayerContourToExistenceVector a :CompleteToolSpecification;
    wf:input1 _:in11_13;
    wf:output _:out12_13;
    cct:expression
        "revert (select (compose2 notj leq) (1: Contour) (-: Ord))".
_:in11_13
    wf:proxyFor _:in11;
    a ccd:FieldQ, ccd:VectorTessellationA, ccd:OrdinalA.
    # Contour is a coverage that is a subclass of coverage and ordinalA, and
    # therefore also allows field rasters, which we don't want in this context.
_:out12_13
    wf:proxyFor _:out12;
    a ccd:FieldQ, ccd:PlainVectorRegionA, ccd:OrdinalA.

#### Object selection variant vith gteq, needs a ratio attribute
tools:SelectLayerByRatioGEQPlainRegionObjects a :CompleteToolSpecification;
    wf:input1 _:in11_14;
    wf:output _:out12_14;
    cct:expression
        "select (compose2 notj leq) (1: ObjectInfo(Ratio)) (-: Ratio)".
_:in11_14
    wf:proxyFor _:in11;
    a ccd:ObjectQ, ccd:PlainVectorRegionA, ccd:RatioA.
_:out12_14
    wf:proxyFor _:out12;
    a ccd:ObjectQ, ccd:PlainVectorRegionA, ccd:RatioA.

#### Coverage to Existence Vector
tools:SelectLayerCoverageToExistenceVector a :CompleteToolSpecification;
    wf:input1 _:in11_15;
    wf:output _:out12_15;
    cct:expression
        "revert (select eq (1: Coverages(Nom)) (-: Nom))".
_:in11_15
    wf:proxyFor _:in11;
    a ccd:FieldQ, ccd:VectorTessellationA.
    # Coverage is defined as a subclass of FieldQ and TesselationA, and
    # therefore also allows field rasters, which we don't want in this context.
_:out12_15
    wf:proxyFor _:out12;
    a ccd:FieldQ, ccd:PlainVectorRegionA.



#### Select layer by location
tools:FullSelectLayerByLocation a :ToolCombination;
    tools:implements 
        tools:SelectLayerByLocationPointObjects, 
        tools:SelectLayerByLocationLineObjects,
        tools:SelectLayerByLocationPlainRegionObjects,
        tools:SelectLayerByLocationTessObjects, 
        tools:SelectLayerByLocationPlainRegionObjectsFieldDist, 
        tools:SelectLayerByLocationPlainRegionObjectsDist;
    wf:edge _:wf2_1, _:wf2_2;
    wf:source _:in211, _:in212.
_:wf2_1 wf:applicationOf tools:SelectLayerByLocationDef;
    wf:input1 _:in211;
    wf:input2 _:in212;
    wf:output _:out21.
_:wf2_2 wf:applicationOf tools:CopyFeaturesDef;
    wf:input1 _:out21;
    wf:output _:out22.

#### Object selection variant
tools:SelectLayerByLocationPointObjects a :CompleteToolSpecification;
    wf:input1 _:in211_1;
    wf:input2 _:in212_1;
    wf:output _:out22_1;
    cct:expression
        """
        1: ObjectInfo(Nom);
        2: ObjectInfo(Nom);
        subset
            1
            (pi1 (select
                eq
                (oTopo (get_attrL 1) (get_attrL 2))
                in
            ))
        """.
_:in211_1
    wf:proxyFor _:in211;
    a ccd:ObjectQ, ccd:PointA.
_:in212_1
    wf:proxyFor _:in212;
    a ccd:ObjectQ, ccd:VectorA.
_:out22_1
    wf:proxyFor _:out22;
    a ccd:ObjectQ, ccd:PointA.

#### Object selection variant
tools:SelectLayerByLocationLineObjects a :CompleteToolSpecification;
    wf:input1 _:in211_2;
    wf:input2 _:in212_2;
    wf:output _:out22_2;
    cct:expression
        """
        1: ObjectInfo(Nom);
        2: ObjectInfo(Nom);
        subset
            1
            (pi1 (select
                eq
                (oTopo (get_attrL 1) (get_attrL 2))
                in
            ))
        """.
_:in211_2
    wf:proxyFor _:in211;
    a ccd:ObjectQ, ccd:LineA.
_:in212_2
    wf:proxyFor _:in212;
    a ccd:ObjectQ, ccd:VectorA.
_:out22_2
    wf:proxyFor _:out22;
    a ccd:ObjectQ, ccd:LineA.

#### Object selection variant
tools:SelectLayerByLocationPlainRegionObjects a :CompleteToolSpecification;
    wf:input1 _:in211_3;
    wf:input2 _:in212_3;
    wf:output _:out22_3;
    cct:expression
        """
        1: ObjectInfo(Nom);
        2: ObjectInfo(Nom);
        subset
            1
            (pi1 (select
                eq
                (oTopo (get_attrL 1) (get_attrL 2))
                in
            ))
        """.
_:in211_3
    wf:proxyFor _:in211;
    a ccd:ObjectQ, ccd:PlainVectorRegionA.
_:in212_3
    wf:proxyFor _:in212;
    a ccd:ObjectQ, ccd:VectorA.
_:out22_3
    wf:proxyFor _:out22;
    a ccd:ObjectQ, ccd:PlainVectorRegionA.

#### Object selection variant
tools:SelectLayerByLocationTessObjects a :CompleteToolSpecification;
    wf:input1 _:in211_4;
    wf:input2 _:in212_4;
    wf:output _:out22_4;
    cct:expression
        """
        1: ObjectInfo(Nom);
        2: ObjectInfo(Nom);
        subset
            1
            (pi1 (select
                eq
                (oTopo (get_attrL 1) (get_attrL 2))
                in
            ))
        """.
_:in211_4
    wf:proxyFor _:in211;
    a ccd:ObjectQ, ccd:VectorTessellationA.
_:in212_4
    wf:proxyFor _:in212;
    a ccd:ObjectQ, ccd:VectorA.
_:out22_4
    wf:proxyFor _:out22;
    a ccd:ObjectQ, ccd:VectorTessellationA.

#### Object selection variant with vector field patches
tools:SelectLayerByLocationPlainRegionObjectsFieldDist a :CompleteToolSpecification;
    wf:input1 _:in211_5;
    wf:input2 _:in212_5;
    wf:output _:out22_5;
     cct:expression
        """
        1: ObjectInfo(Nom);
        2: Field(Nom);
        subset
            1
            (pi3 (select
                eq
                (loTopo (pi1 2) (get_attrL 1))
                in
            ))
        """.
_:in211_5
    wf:proxyFor _:in211;
    a ccd:ObjectQ, ccd:PlainVectorRegionA.
_:in212_5
    wf:proxyFor _:in212;
    a ccd:FieldQ, ccd:VectorRegionA.
_:out22_5
    wf:proxyFor _:out22;
    a ccd:ObjectQ, ccd:PlainVectorRegionA.

#### Object selection variant with distance
tools:SelectLayerByLocationPlainRegionObjectsDist a :CompleteToolSpecification;
    wf:input1 _:in211_6;
    wf:input2 _:in212_6;
    wf:output _:out22_6;
     cct:expression
        """
        1: ObjectInfo(Nom);
        2: ObjectInfo(Nom);
        subset
            1
            (pi1 (select
                leq
                (oDist (get_attrL 1) (get_attrL 2))
                (-: Ratio)
            ))
        """.
_:in211_6
    wf:proxyFor _:in211;
    a ccd:ObjectQ, ccd:PlainVectorRegionA.
_:in212_6
    wf:proxyFor _:in212;
    a ccd:ObjectQ, ccd:VectorA.
_:out22_6
    wf:proxyFor _:out22;
    a ccd:ObjectQ, ccd:PlainVectorRegionA.



#### Spatial join

######### Spatial join with sum rule
# with JOIN_ONE_TO_ONE parameter, with Merge_RULe sum for Ratio data.
tools:SpatialJoinSumTessRatio a :CompleteToolSpecification;
    wf:input1 [ a ccd:ObjectQ, ccd:VectorA, exm:ERA ];
    wf:input2 [ a ccd:ObjectQ, ccd:VectorTessellationA ];
    wf:output [ a ccd:ObjectQ, ccd:VectorTessellationA, exm:ERA ];
    rdfs:comment
        "Sums the attributes at ratio measurement level from one feature to another based on the spatial relation";
    cct:expression
        """
        1: ObjectInfo(Ratio);
        2: ObjectInfo(Nom);
        join_attr
            (get_attrL 2)
            (join (get_attrL 2) (groupbyR sum (join_key
                (select eq (rTopo
                    (pi2 (get_attrL 1))
                    (pi2 (get_attrL 2))
                ) in)
                (getamounts 1)
            )))
        """.

# with JOIN_ONE_TO_ONE parameter, with Merge_RULe sum for Count data.
tools:SpatialJoinSumTessCount a :CompleteToolSpecification;
    wf:input1 [ a ccd:ObjectQ, ccd:VectorA, ccd:CountA ];
    wf:input2 [ a ccd:ObjectQ, ccd:VectorTessellationA ];
    wf:output [ a ccd:ObjectQ, ccd:VectorTessellationA, ccd:CountA ];
    rdfs:comment
        "Sums the attributes at Count measurement level from one feature to another based on the spatial relation";
    cct:expression
        """
        1: ObjectInfo(Count);
        2: ObjectInfo(Nom);
        join_attr
            (get_attrL 2)
            (join (get_attrL 2) (groupbyR sum (join_key
                (select eq (rTopo
                    (pi2 (get_attrL 1))
                    (pi2 (get_attrL 2))
                ) in)
                (getamounts 1)
            )))
        """.

######### Spatial join with sum rule with vector amounts
# with JOIN_ONE_TO_ONE parameter, with Merge_RULe sum for Ratio data.
tools:SpatialJoinAmountSumTessRatio a :CompleteToolSpecification;
    wf:input1 [ a ccd:AmountQ, ccd:VectorRegionA, exm:ERA ];
    wf:input2 [ a ccd:ObjectQ, ccd:VectorTessellationA ];
    wf:output [ a ccd:ObjectQ, ccd:VectorTessellationA, exm:ERA ];
    rdfs:comment
        "Sums the attributes at ratio measurement level from one feature to another based on the spatial relation";
    cct:expression
        """
        1: Amounts(Ratio);
        2: ObjectInfo(Nom);
        join_attr
            (get_attrL 2) (join
                (get_attrL 2)
                (groupbyR sum (join_key
                    (select
                        eq
                        (rTopo (pi1 1) (pi2 (get_attrL 2)))
                        in)
                    1
                ))
            )
        """.

# with JOIN_ONE_TO_ONE parameter, with Merge_RULe sum for Count data.
tools:SpatialJoinAmountSumTessCount a :CompleteToolSpecification;
    wf:input1 [ a ccd:AmountQ, ccd:VectorRegionA, ccd:CountA ];
    wf:input2 [ a ccd:ObjectQ, ccd:VectorTessellationA ];
    wf:output [ a ccd:ObjectQ, ccd:VectorTessellationA, ccd:CountA ];
    rdfs:label
        "Sums the attributes at Count measurement level from one feature to another based on the spatial relation";
    cct:expression
        """
        1: Amounts(Count);
        2: ObjectInfo(Nom);
        join_attr
            (get_attrL 2)
            (join
                (get_attrL 2)
                (groupbyR sum (join_key
                    (select
                        eq
                        (rTopo (pi1 1) (pi2 (get_attrL 2)))
                        in
                    )
                    1
                ))
            )
        """.

#### spatial join with mean rule
# with JOIN_ONE_TO_ONE parameter, with Merge_RULe mean for interval data.
tools:SpatialJoinMeanTessInterval a :CompleteToolSpecification;
    wf:input1 [ a ccd:ObjectQ, ccd:VectorA, ccd:IntervalA ];
    wf:input2 [ a ccd:ObjectQ, ccd:VectorTessellationA ];
    wf:output [ a ccd:ObjectQ, ccd:VectorTessellationA, ccd:IntervalA ];
    rdfs:comment
    "Averages the attributes at interval measurement level from one feature to another based on the spatial relation";
    cct:expression
        """
        1: ObjectInfo(Ratio);
        2: ObjectInfo(Nom);
        join_attr
            (get_attrL 2)
            (join
                (get_attrL 2)
                (groupbyR avg (join_key (select eq (rTopo
                    (pi2 (get_attrL 1))
                    (pi2 (get_attrL 2))
                ) in) (getamounts 1)))
            )
        """.

# with JOIN_ONE_TO_ONE parameter, with Merge_RULe mean for Ratio data.
tools:SpatialJoinMeanTessRatio a :CompleteToolSpecification;
    wf:input1 [ a ccd:ObjectQ, ccd:VectorA, ccd:RatioA ];
    wf:input2 [ a ccd:ObjectQ, ccd:VectorTessellationA ];
    wf:output [ a ccd:ObjectQ, ccd:VectorTessellationA, ccd:RatioA ];
    rdfs:comment
        "Averages the attributes at Ratio measurement level from one feature to another based on the spatial relation";
    cct:expression
        """
        1: ObjectInfo(Ratio);
        2: ObjectInfo(Nom);
        join_attr
            (get_attrL 2)
            (join
                (get_attrL 2)
                (groupbyR avg (join_key (select eq (rTopo
                    (pi2 (get_attrL 1))
                    (pi2 (get_attrL 2))
                ) in) (getamounts 1)))
            )
        """.

# with JOIN_ONE_TO_ONE parameter, with Merge_RULe mean for Count data.
tools:SpatialJoinMeanTessCount a :CompleteToolSpecification;
    wf:input1 [ a ccd:ObjectQ, ccd:VectorA, ccd:CountA ];
    wf:input2 [ a ccd:ObjectQ, ccd:VectorTessellationA ];
    wf:output [ a ccd:ObjectQ, ccd:VectorTessellationA, ccd:CountA ];
    rdfs:comment
        "Averages the attributes at Count measurement level from one feature to another based on the spatial relation";
    cct:expression
        """
        1: ObjectInfo(Count);
        2: ObjectInfo(Nom);
        join_attr
            (get_attrL 2)
            (join
                (get_attrL 2)
                (groupbyR avg (join_key (select eq (rTopo
                    (pi2 (get_attrL 1))
                    (pi2 (get_attrL 2))
                ) in) (getamounts 1)))
            )
        """.

#### spatial join with the count rule
# with JOIN_ONE_TO_ONE parameter and with Merge_RULe count.
tools:SpatialJoinCountTess a :CompleteToolSpecification;
    wf:input1 [ a ccd:ObjectQ, ccd:VectorA ];
    wf:input2 [ a ccd:ObjectQ, ccd:VectorTessellationA ];
    wf:output [ a ccd:ObjectQ, ccd:VectorTessellationA, ccd:CountA ];
    rdfs:comment
        "Counts the number of features from one feature to another based on the spatial relation";
    cct:expression
        """
        1: ObjectInfo(Nom);
        2: ObjectInfo(Nom);
        join_attr
            (get_attrL 2)
            (apply1
                (ocont (get_attrL 1))
                (get_attrL 2)
            )
        """.


### Scenario: Noise (noisePortionAmsterdam.ttl, noiseProPortionAmsterdam.ttl (=raster version), noiseProPortionAmsterdam2.ttl (= vector version))
### Source: own
#-------------------------------

#Noise portion

tools:ClipFieldRaster2ObjectExtent a :CompleteToolSpecification;
    wf:input1 [ a ccd:FieldRaster, ccd:OrdinalA ];
    wf:input2 [ a ccd:ObjectVector ];
    wf:output [ a ccd:FieldRaster, ccd:OrdinalA];
    rdfs:comment
        "Clips some interval scaled field raster to the extent of an object layer.";
    cct:expression #"bowtie field x deify merge pi2 objectregions x".
        """
        1: Field(Ord);
        2: ObjectInfo(Nom);
        subset 1 (deify (ocover
            (get_attrL 2)
            (pi1 (get_attrL 2))
        ))
        """.

tools:RegionFromRasterExtent a :CompleteToolSpecification;
    wf:input1 [ a ccd:FieldRaster, ccd:NominalA ];
    wf:output [ a ccd:AmountQ, ccd:VectorRegionA, ccd:NominalA ];
    rdfs:comment
        "Make a region layer from the extent of a raster. Measures the coverage of a nominal field.";
    cct:expression
        """
        1: Field(Nom);
        nest2 (name (pi2 1)) (reify (fcover 1 (pi2 1)))
        """.

#Noise proportion (raster)

#<https://pro.arcgis.com/en/pro-app/tool-reference/conversion/polygon-to-raster.htm>
###Field Polygon to raster
tools:CoverageToNominalFieldRaster a :CompleteToolSpecification;
    wf:input1 [ a ccd:Coverage, ccd:PlainNominalA ];
    wf:output [ a ccd:FieldRaster, ccd:PlainNominalA ];
    rdfs:comment
        "Converts Field polygons to nominal field Rasters";
    cct:expression
        "revert (1: Coverages(Nom))".

tools:ContourToFieldRaster a :CompleteToolSpecification;
    wf:input1 [ a ccd:Contour ];
    wf:output [ a ccd:FieldRaster, ccd:PlainOrdinalA ];
    rdfs:comment
        "Converts contour maps to field Rasters";
    cct:expression
        "revert (1: Contour)".

#<https://pro.arcgis.com/en/pro-app/tool-reference/spatial-analyst/raster-calculator.htm>

### local map algebra with only a single input layer
tools:LocalMapAlgebraSubOrder a :CompleteToolSpecification;
    wf:input1 [ a ccd:FieldRaster, ccd:OrdinalA ];
    wf:output [ a ccd:FieldRaster, ccd:OrdinalA ];
    rdfs:comment
        "Builds and executes a Local Map Algebra expression (smaller than or greater than some number) using Python syntax using rasters with an ordinal level";
    cct:expression
        "select (compose2 notj leq) (1: Field(Ord)) (-: Ord)".

### local map algebra transformation with ratio field
tools:LocalMapAlgebraSubRatio a :CompleteToolSpecification;
    wf:input1 [ a ccd:FieldRaster, ccd:RatioA ];
    wf:output [ a ccd:FieldRaster, ccd:RatioA ];
    rdfs:comment
        "Builds and executes a Local Map Algebra expression (less than or equal to some number) using Python syntax using rasters with a ratio level";
    cct:expression
        "select (compose2 notj leq) (1: Field(Ratio)) (-: Ratio)".

tools:RasterToContour a :ToolCombination;
    tools:implements tools:RasterToContourInterval;
    wf:edge _:wf3_1, _:wf3_2;
    wf:source _:in31.
_:wf3_1 wf:applicationOf tools:RasterToIsoRaster;
    wf:input1 _:in31;
    wf:output _:out31.
_:wf3_2 wf:applicationOf tools:RegionFromRasterExtent;
    wf:input1 _:out31;
    wf:output _:out32.

tools:RasterToContourInterval a :CompleteToolSpecification;
    wf:input1 _:in31;
    wf:output _:out32;
    rdfs:comment
        "Converts a field raster to a Contour dataset. The raster is first reclassified to an ordinal raster, and then converted to a polygon layer.";
    cct:expression
        "invert (apply1 classify (1: Field(Itv)))".
_:in31 a ccd:FieldRaster, ccd:IntervalA.
_:out32 a ccd:Contour, ccd:PlainOrdinalA.


#<https://pro.arcgis.com/en/pro-app/tool-reference/spatial-analyst/zonal-statistics-as-table.htm>+<https://pro.arcgis.com/en/pro-app/tool-reference/data-management/join-field.htm>

tools:ZonalStatistics a :ToolCombination;
    tools:implements 
        tools:ZonalStatisticsSize, 
        tools:ZonalStatisticsMeanInterval, 
        tools:ZonalStatisticsMeanRatio, 
        tools:ZonalStatisticsSumCount;
    wf:edge _:wf4_1, _:wf4_2;
    wf:source _:in411, _:in412.
_:wf4_1 wf:applicationOf tools:ZonalStatisticsAsTableDef;
    wf:input1 _:in411;
    wf:input2 _:in412;
    wf:output _:out41.
_:wf4_2 wf:applicationOf tools:JoinFieldDef;
    wf:input1 _:out41;
    wf:input2 _:in412;
    wf:output _:out42.

tools:ZonalStatisticsSize a :ToolCombination;
    wf:input1 _:in411_1;
    wf:input2 _:in412_1;
    wf:output _:out42_1;
    rdfs:comment
        "Measures the size of the coverage of a given field raster inside object regions.";
    cct:expression
        """
        1: Field(Nom);
        2: ObjectInfo(Nom);
        join_attr
            (get_attrL 2)
            (groupbyR size (select eq (loTopo
                (fcover 1 (-: C(Nom)))
                (get_attrL 2)
            ) in))
        """.
_:in411_1
    wf:proxyFor _:in411;
    a ccd:FieldRaster, ccd:NominalA.
_:in412_1
    wf:proxyFor _:in412;
    a ccd:ObjectQ, ccd:VectorRegionA.
_:out42_1
    wf:proxyFor _:out42;
    a ccd:ObjectQ, ccd:VectorRegionA, exm:ERA.

#Zonal Statistics
tools:ZonalStatisticsMeanInterval a :CompleteToolSpecification;
    wf:input1 _:in411_2;
    wf:input2 _:in412_2;
    wf:output _:out42_2;
    rdfs:comment
        "Calculates the average value of a field raster within the zones of a lattice.";
    cct:expression #"groupby_avg bowtie* sigmae lotopo pi1 field x objectregions y in field x".
        """
        1: Field(Itv);
        2: ObjectInfo(Nom);
        join_attr
            (get_attrL 2)
            (apply1 (fcont avg 1) (get_attrL 2))
        """.
_:in411_2
    wf:proxyFor _:in411;
    a ccd:FieldRaster, ccd:IntervalA.
_:in412_2
    wf:proxyFor _:in412;
    a ccd:ObjectQ, ccd:VectorTessellationA.
_:out42_2
    wf:proxyFor _:out42;
    a ccd:ObjectQ, ccd:VectorTessellationA, ccd:IntervalA.

tools:ZonalStatisticsMeanRatio a :CompleteToolSpecification;
    wf:input1 _:in411_3;
    wf:input2 _:in412_3;
    wf:output _:out42_3;
    rdfs:comment
        "Calculates the average value of a field raster within the zones given by object regions. Outcome is intensive.";
    cct:expression
        #"groupby_avg bowtie* sigmae lotopo pi1 field x objectregions y in field x".
        #"join_attr (get_attrL (objectregionnominals x2)) (apply1 (fcont (avg) (field x1)) (get_attrL (objectregionnominals x2)))".
        """
        1: Field(Ratio);
        2: ObjectInfo(Nom);
        join_attr
            (get_attrL 2)
            (groupbyR avg (join_key
                (select eq (loTopo (pi1 1) (get_attrL 2)) in)
                1
            ))
        """.
_:in411_3
    wf:proxyFor _:in411;
    a ccd:FieldRaster, ccd:RatioA.
_:in412_3
    wf:proxyFor _:in412;
    a ccd:ObjectQ, ccd:PlainVectorRegionA.
_:out42_3
    wf:proxyFor _:out42;
    a ccd:ObjectQ, ccd:PlainVectorRegionA, exm:IRA.

#Zonal statistics: sum of count amounts
tools:ZonalStatisticsSumCount a :CompleteToolSpecification;
    wf:input1 _:in411_4;
    wf:input2 _:in412_4;
    wf:output _:out42_4;
    rdfs:comment
        "Sums up count amounts (given as raster) into object regions.";
    cct:expression #"groupby_avg bowtie* sigmae lotopo pi1 field x objectregions y in field x".
        """
        1: Amounts(Count);
        2: ObjectInfo(Nom);
        join_attr
            (get_attrL 2)
            (groupbyL
                sum
                (join_key (orTopo (get_attrL 2) (pi1 1)) 1)
            )
        """.
_:in411_4
    wf:proxyFor _:in411;
    a ccd:AmountQ, ccd:RasterA, ccd:CountA.
_:in412_4
    wf:proxyFor _:in412;
    a ccd:ObjectQ, ccd:VectorRegionA.
_:out42_4
    wf:proxyFor _:out42;
    a ccd:ObjectQ, ccd:VectorRegionA, ccd:CountA.



tools:AddObjectVectorRegionArea a :CompleteToolSpecification;
    wf:input1 [ a ccd:ObjectQ, ccd:VectorRegionA ];
    wf:output [ a ccd:ObjectQ, ccd:VectorRegionA, exm:ERA ];
    rdfs:comment
        "Adds an area attribute to an object vector region layer.";
    cct:expression
        """
        1: ObjectInfo(Nom);
        join_attr
            (get_attrL 1)
            (apply1
                (compose size deify)
                (get_attrL 1)
            )
        """.

### noise proportion (vector version)

#this tool computes the coverage of a field inside object region by first intersecting and then dissolving  and joining, to obtain the area covered by the field inside the object region
tools:IntersectDissolve a :ToolCombination;
    tools:implements tools:IntersectDissolveField2Object;
    wf:edge _:wf8_1, _:wf8_2, _:wf8_3;
    wf:source _:in81, _:in82.
_:wf8_1 wf:applicationOf tools:IntersectDef;
    wf:input1 _:in81;
    wf:input2 _:in82;
    wf:output _:out81.
_:wf8_2 wf:applicationOf tools:MergeObjects;
    wf:input1 _:out81;
    wf:output _:out82.
_:wf8_3 wf:applicationOf tools:JoinFieldDef;
    wf:input1 _:out82;
    wf:input2 _:in82;
    wf:output _:out83.

##Coverage of vector field in object
tools:IntersectDissolveField2Object a :CompleteToolSpecification;
    wf:input1 _:in81;
    wf:input2 _:in82;
    wf:output _:out83;
    rdfs:comment
        "Intersects a field vector with an object vector and then dissolves the result into the object to measure the areal coverage of the field inside the object.";
    cct:expression
        """
        1: Field(Nom);
        2: ObjectInfo(_);
        join_attr
            (get_attrL 2)
            (groupbyR size (select eq (loTopo
                (fcover 1 (-: C(Nom)))
                (get_attrL 2)
            ) in))
        """.
_:in81 a ccd:FieldQ, ccd:VectorRegionA.
_:in82 a ccd:ObjectQ,  ccd:VectorRegionA.
_:out83 a ccd:ObjectQ,  ccd:VectorRegionA, exm:ERA.


### Scenario: Temperature (amountFieldUtrecht.ttl)
### Source: own
#-------------------------------

tools:MakeLayerFromTable a :ToolCombination;
    tools:implements tools:MakePointMeasuresFromTable;
    wf:edge _:wf5_1, _:wf5_2, _:wf5_3,_:wf5_4;
    wf:source _:in51.
_:wf5_1  wf:applicationOf tools:MakeXyEventLayerDef;
    wf:input1 _:in51;
    wf:output _:out51.
_:wf5_2  wf:applicationOf tools:ProjectDef;
    wf:input1 _:out51;
    wf:output _:out52.
_:wf5_3  wf:applicationOf tools:ExcelToTableDef;
    wf:input1 _:in51;
    wf:output _:temp.
_:wf5_4  wf:applicationOf tools:JoinFieldDef;
    wf:input1 _:out52;
    wf:input2 _:temp;
    wf:output _:out53.

tools:MakePointMeasuresFromTable a :CompleteToolSpecification;
    wf:input1 _:in51;
    wf:output _:out53;
    rdfs:comment
        "Makes a layer of pointmeasures from some XY table.";
    cct:expression
        "1: PointMeasures" .
_:in51 a ccd:PointMeasures, ccd:IntervalA.
_:out53 a ccd:PointMeasures, ccd:IntervalA.

tools:IDWInterval a :CompleteToolSpecification;
    wf:input1 [ a ccd:PointMeasures, ccd:IntervalA ];
    wf:output [ a ccd:FieldRaster, ccd:IntervalA ];
    rdfs:comment
        "Standard point interpolation for interval measurements.";
    cct:expression
        "interpol (1: PointMeasures) (deify (-: Reg))".

tools:KrigingInterval a :CompleteToolSpecification;
    wf:input1 [ a ccd:PointMeasures, ccd:IntervalA ];
    wf:output [ a ccd:FieldRaster, ccd:IntervalA ];
    rdfs:comment
        "Kriging point interpolation for interval measurements.";
    cct:expression
        "interpol (1: PointMeasures) (deify (-: Reg))".


##################################################
# [SC] arcpro tools

arcprodm:add-geometry-attributes.htm a :ToolImplementation;
    tools:implements tools:AddObjectVectorRegionArea.

arcpro3d:aspect.htm a :ToolImplementation;
    tools:implements tools:Aspect.

##Buffer (interpreted as vector representation of boolean field)
arcproan:buffer.htm a :ToolImplementation;
    tools:implements tools:ObjectBuffer.

#Builds ratio network from line objects
arcprona:build-network.htm a :ToolImplementation;
    tools:implements tools:BuildNetwork.

arcprodm:clip.htm a :ToolImplementation;
    tools:implements 
        tools:ClipObject2Object, 
        tools:ClipNomFieldVector2Extent, 
        tools:ClipBoolFieldVector2Extent, 
        tools:ClipFieldRaster2ObjectExtent,
        tools:ClipDef.

arcprosa:con-.htm a :ToolImplementation;
    tools:implements 
        tools:con1, 
        tools:con2, 
        tools:con3.

##Merge object parts into single object
arcprodm:dissolve.htm a :ToolImplementation;
    tools:implements tools:MergeObjects.

##Erase Vector fields
arcproan:erase.htm a :ToolImplementation;
    tools:implements tools:EraseFieldExtentfromFieldVector.

arcprosa:extract-by-mask.htm a :ToolImplementation;
    tools:implements tools:ExtractByMask.

##Feature class to feature class (=Select)
arcproco:feature-class-to-feature-class.htm a :ToolImplementation;
    tools:implements tools:FC2FCObjectTess.

#Flow direction accumulation
arcprosa:flow-accumulation.htm a :ToolImplementation;
    tools:implements tools:FlowAccumulation.

#Flow direction raster
arcprosa:flow-direction.htm a :ToolImplementation;
    tools:implements tools:FlowDirection.

arcprosa:flow-length.htm a :ToolImplementation;
    tools:implements tools:FlowLength.

#Near tool, to seach for the closest objects using Euclidean distance
arcproan:generate-near-table.htm a :ToolImplementation;
    tools:implements tools:NearPointObjects.

arcprosa:idw.htm a :ToolImplementation;
    tools:implements tools:IDWInterval.

arcprosa:kriging.htm a :ToolImplementation;
    tools:implements tools:KrigingInterval.

#<https://pro.arcgis.com/en/pro-app/tool-reference/conversion/polygon-to-raster.htm>
###Field Polygon to raster
arcproco:polygon-to-raster.htm a :ToolImplementation;
    tools:implements 
        tools:CoverageToNominalFieldRaster, 
        tools:ContourToFieldRaster.

arcprosa:raster-calculator.htm a :ToolImplementation;
    tools:implements 
        ### local map algebra transformation invert
        tools:LocalMapAlgebraInvert,
        ### local map algebra divide
        tools:LocalMapAlgebraDivide,
        ### local map algebra with only a single input layer
        tools:LocalMapAlgebraSubOrder, 
        tools:LocalMapAlgebraSubRatio,
        tools:RasterCalculatorDef,
        tools:RasterCalculator1Def.
    
arcproco:raster-to-polygon.htm a :ToolImplementation;
    tools:implements tools:RegionFromRasterExtent.

arcprosa:reclassify.htm a :ToolImplementation;
    tools:implements tools:RasterToIsoRaster.

##Select object by extent
arcproan:select.htm a :ToolImplementation;
    tools:implements tools:SelectObjectbyExtent. 

#Slope computation
arcprosa:slope.htm a :ToolImplementation;
   tools:implements tools:Slope.

#Snap point to raster
arcprosa:snap-pour-point.htm a :ToolImplementation;
    tools:implements tools:SnapPourPoint.

arcproan:spatial-join.htm a :ToolImplementation;
    tools:implements 
        # with JOIN_ONE_TO_ONE parameter, with Merge_RULe sum for Ratio data.
        tools:SpatialJoinSumTessRatio,
        # with JOIN_ONE_TO_ONE parameter, with Merge_RULe sum for Count data.
        tools:SpatialJoinSumTessCount,
        # with JOIN_ONE_TO_ONE parameter, with Merge_RULe sum for Ratio data.
        tools:SpatialJoinAmountSumTessRatio,
        # with JOIN_ONE_TO_ONE parameter, with Merge_RULe sum for Count data.
        tools:SpatialJoinAmountSumTessCount,
        # with JOIN_ONE_TO_ONE parameter, with Merge_RULe mean for interval data.
        tools:SpatialJoinMeanTessInterval,
        # with JOIN_ONE_TO_ONE parameter, with Merge_RULe mean for Ratio data.
        tools:SpatialJoinMeanTessRatio,
        # with JOIN_ONE_TO_ONE parameter, with Merge_RULe mean for Count data.
        tools:SpatialJoinMeanTessCount,
        # with JOIN_ONE_TO_ONE parameter and with Merge_RULe count.
        tools:SpatialJoinCountTess.

##Summary statistics for amounts
arcproan:summary-statistics.htm a :ToolImplementation;
    tools:implements 
        tools:ObjectSummaryStatisticsAmount, 
        tools:SummaryStatisticsAmount. 

arcprosa:watershed.htm a :ToolImplementation;
    tools:implements tools:Watershed.


##################################################
# [SC] these arcpro tools need to be annotated

tools:ClipDef a :PartialToolSpecification;
    # [SC][TODO] annotate inputs and output
    wf:input1 [ a ccd:CoreConceptQ, ccd:VectorRegionA, ccd:NominalA ];
    wf:input2 [ a ccd:CoreConceptQ, ccd:VectorRegionA, ccd:NominalA ];
    wf:output [ a ccd:CoreConceptQ, ccd:VectorRegionA, ccd:NominalA ];
    rdfs:comment
        "This is the default annotation for the Clip arcpro tool to be used when an algebra expression is not possible to produce.";
    cct:expression "".
    
tools:RasterCalculatorDef a :PartialToolSpecification;
    # [SC][TODO] annotate inputs and output
    wf:input1 [ a ccd:CoreConceptQ, ccd:RasterA, ccd:NominalA ];
    wf:input2 [ a ccd:CoreConceptQ, ccd:RasterA, ccd:NominalA ];
    wf:output [ a ccd:CoreConceptQ, ccd:RasterA, ccd:NominalA ];
    rdfs:comment
        "This is the default annotation for the Raster Calculator arcpro tool to be used when an algebra expression is not possible to produce.";
    cct:expression "".
    
tools:RasterCalculator1Def a :PartialToolSpecification;
    # [SC][TODO] annotate inputs and output
    wf:input1 [ a ccd:CoreConceptQ, ccd:RasterA, ccd:NominalA ];    
    wf:output [ a ccd:CoreConceptQ, ccd:RasterA, ccd:NominalA ];
    rdfs:comment
        "This is the default annotation for the Raster Calculator arcpro tool to be used when an algebra expression is not possible to produce.";
    cct:expression "".    

arcprona:make-closest-facility-analysis-layer.htm
    tools:implements tools:MakeClosestFacilityAnalysisLayerDef.
tools:MakeClosestFacilityAnalysisLayerDef a :PartialToolSpecification;
    # [SC][TODO] annotate inputs and output    
    wf:input1 [ a ccd:NetworkQ, ccd:LineA, ccd:RatioA ];    
    wf:output [ a ccd:NetworkQ, ccd:LineA, ccd:RatioA ];
    rdfs:comment
        "This is the default annotation for the Make Closest Facility Analysis Layer arcpro tool to be used when an algebra expression is not possible to produce.";
    cct:expression "".

arcprona:add-locations.htm
    tools:implements tools:AddLocationsDef.
tools:AddLocationsDef a :PartialToolSpecification;
    # [SC][TODO] annotate inputs and output
    wf:input1 [ a ccd:NetworkQ, ccd:LineA, ccd:RatioA ];
    wf:input2 [ a ccd:CoreConceptQ, ccd:PointA, ccd:NominalA ];
    wf:output [ a ccd:NetworkQ, ccd:LineA, ccd:RatioA ];
    rdfs:comment
        "This is the default annotation for the Add Locations arcpro tool to be used when an algebra expression is not possible to produce.";
    cct:expression "".

arcprona:solve.htm
    tools:implements tools:SolveDef.
tools:SolveDef a :PartialToolSpecification;
    # [SC][TODO] annotate inputs and output
    wf:input1 [ a ccd:NetworkQ, ccd:LineA, ccd:RatioA ];    
    wf:output [ a ccd:ObjectQ, ccd:PointA, ccd:RatioA ];
    rdfs:comment
        "This is the default annotation for the Solve arcpro tool to be used when an algebra expression is not possible to produce.";
    cct:expression "".

arcproco:excel-to-table.htm
    tools:implements tools:ExcelToTableDef.
tools:ExcelToTableDef a :PartialToolSpecification;
    # [SC][TODO] annotate inputs and output
    wf:input1 [ a ccd:CoreConceptQ, ccd:VectorA, ccd:NominalA ];    
    wf:output [ a ccd:CoreConceptQ, ccd:VectorA, ccd:NominalA ];
    rdfs:comment
        "This is the default annotation for the Excel To Table arcpro tool to be used when an algebra expression is not possible to produce.";
    cct:expression "".

arcprodm:join-field.htm
    tools:implements tools:JoinFieldDef.
tools:JoinFieldDef a :PartialToolSpecification;
    # [SC][TODO] annotate inputs and output
    wf:input1 [ a ccd:CoreConceptQ, ccd:VectorA, ccd:NominalA ];
    wf:input2 [ a ccd:CoreConceptQ, ccd:VectorA, ccd:NominalA ];
    wf:output [ a ccd:CoreConceptQ, ccd:VectorA, ccd:NominalA ];
    rdfs:comment
        "This is the default annotation for the Join Field arcpro tool to be used when an algebra expression is not possible to produce.";
    cct:expression "".

arcproco:table-to-table.htm
    tools:implements tools:TableToTableDef.
tools:TableToTableDef a :PartialToolSpecification;
    # [SC][TODO] annotate inputs and output
    wf:input1 [ a ccd:CoreConceptQ, ccd:RasterA, ccd:NominalA ];    
    wf:output [ a ccd:AmountQ, ccd:VectorRegionA, ccd:RatioA ];
    rdfs:comment
        "This is the default annotation for the Table To Table arcpro tool to be used when an algebra expression is not possible to produce.";
    cct:expression "".

arcprodm:add-field.htm
    tools:implements tools:AddFieldDef.
tools:AddFieldDef a :PartialToolSpecification;
    # [SC][TODO] annotate inputs and output
    wf:input1 [ a ccd:CoreConceptQ, ccd:VectorA, ccd:NominalA ];    
    wf:output [ a ccd:CoreConceptQ, ccd:VectorA, ccd:NominalA ];
    rdfs:comment
        "This is the default annotation for the Add Field arcpro tool to be used when an algebra expression is not possible to produce.";
    cct:expression "".

arcprodm:calculate-field.htm
    tools:implements tools:CalculateFieldDef, tools:CalculateField2Def.
tools:CalculateFieldDef a :PartialToolSpecification;
    # [SC][TODO] annotate inputs and output
    wf:input1 [ a ccd:CoreConceptQ, ccd:VectorA, ccd:NominalA ];    
    wf:output [ a ccd:CoreConceptQ, ccd:VectorA, ccd:NominalA ];
    rdfs:comment
        "This is the default annotation for the Calculate Field arcpro tool to be used when an algebra expression is not possible to produce.";
    cct:expression "".    
tools:CalculateField2Def a :PartialToolSpecification;
    # [SC][TODO] annotate inputs and output
    wf:input1 [ a ccd:CoreConceptQ, ccd:VectorA, ccd:NominalA ];  
	wf:input2 [ a ccd:CoreConceptQ, ccd:VectorA, ccd:NominalA ];     
    wf:output [ a ccd:CoreConceptQ, ccd:VectorA, ccd:NominalA ];
    rdfs:comment
        "This is the default annotation for the Calculate Field arcpro tool to be used when an algebra expression is not possible to produce.";
    cct:expression "".
    

arcprodm:add-fields.htm
    tools:implements tools:AddFieldsDef.
tools:AddFieldsDef a :PartialToolSpecification;
    # [SC][TODO] annotate inputs and output
    wf:input1 [ a ccd:CoreConceptQ, ccd:VectorA, ccd:NominalA ];    
    wf:output [ a ccd:CoreConceptQ, ccd:VectorA, ccd:NominalA ];
    rdfs:comment
        "This is the default annotation for the Add Fields arcpro tool to be used when an algebra expression is not possible to produce.";
    cct:expression "".

arcprodm:select-layer-by-attribute.htm
    tools:implements tools:SelectLayerByAttributeDef.
tools:SelectLayerByAttributeDef a :PartialToolSpecification;
    # [SC][TODO] annotate inputs and output
    wf:input1 [ a ccd:CoreConceptQ, ccd:VectorA, ccd:NominalA ];    
    wf:output [ a ccd:CoreConceptQ, ccd:VectorA, ccd:NominalA ];
    rdfs:comment
        "This is the default annotation for the Select Layer By Attribute arcpro tool to be used when an algebra expression is not possible to produce.";
    cct:expression "".

arcprodm:copy-features.htm
    tools:implements tools:CopyFeaturesDef.
tools:CopyFeaturesDef a :PartialToolSpecification;
    # [SC][TODO] annotate inputs and output
    wf:input1 [ a ccd:CoreConceptQ, ccd:VectorA, ccd:NominalA ];    
    wf:output [ a ccd:CoreConceptQ, ccd:VectorA, ccd:NominalA ];
    rdfs:comment
        "This is the default annotation for the Copy Features arcpro tool to be used when an algebra expression is not possible to produce.";
    cct:expression "".

arcprodm:select-layer-by-location.htm
    tools:implements tools:SelectLayerByLocationDef.
tools:SelectLayerByLocationDef a :PartialToolSpecification;
    # [SC][TODO] annotate inputs and output
    wf:input1 [ a ccd:CoreConceptQ, ccd:VectorA, ccd:NominalA ]; 
	wf:input2 [ a ccd:CoreConceptQ, ccd:VectorA, ccd:NominalA ];     
    wf:output [ a ccd:CoreConceptQ, ccd:VectorA, ccd:NominalA ];
    rdfs:comment
        "This is the default annotation for the Select Layer By Location arcpro tool to be used when an algebra expression is not possible to produce.";
    cct:expression "".

arcprosa:zonal-statistics-as-table.htm
    tools:implements tools:ZonalStatisticsAsTableDef.
tools:ZonalStatisticsAsTableDef a :PartialToolSpecification;
    # [SC][TODO] annotate inputs and output
    wf:input1 [ a ccd:CoreConceptQ, ccd:RasterA, ccd:NominalA ];
    wf:input2 [ a ccd:CoreConceptQ, ccd:VectorRegionA, ccd:NominalA ];
    wf:output [ a ccd:CoreConceptQ, ccd:VectorRegionA, ccd:NominalA ];
    rdfs:comment
        "This is the default annotation for the Zonal Statistics As Table arcpro tool to be used when an algebra expression is not possible to produce.";
    cct:expression "".

arcproan:intersect.htm
    tools:implements tools:IntersectDef.
tools:IntersectDef a :PartialToolSpecification;
    # [SC][TODO] annotate inputs and output
    wf:input1 [ a ccd:CoreConceptQ, ccd:VectorA, ccd:NominalA ];
    wf:input2 [ a ccd:CoreConceptQ, ccd:VectorA, ccd:NominalA ];
    wf:output [ a ccd:CoreConceptQ, ccd:VectorA, ccd:NominalA ];
    rdfs:comment
        "This is the default annotation for the Intersect arcpro tool to be used when an algebra expression is not possible to produce.";
    cct:expression "".

arcprodm:make-xy-event-layer.htm
    tools:implements tools:MakeXyEventLayerDef.
tools:MakeXyEventLayerDef a :PartialToolSpecification;
    # [SC][TODO] annotate inputs and output
    wf:input1 [ a ccd:CoreConceptQ, ccd:PointA, ccd:NominalA ];    
    wf:output [ a ccd:CoreConceptQ, ccd:PointA, ccd:NominalA ];
    rdfs:comment
        "This is the default annotation for the Make Xy Event Layer arcpro tool to be used when an algebra expression is not possible to produce.";
    cct:expression "".

arcprodm:project.htm
    tools:implements tools:ProjectDef.
tools:ProjectDef a :PartialToolSpecification;
    # [SC][TODO] annotate inputs and output
    wf:input1 [ a ccd:CoreConceptQ, ccd:LayerA, ccd:NominalA ];
    wf:input2 [ a ccd:CoreConceptQ, ccd:LayerA, ccd:NominalA ];
    wf:output [ a ccd:CoreConceptQ, ccd:LayerA, ccd:NominalA ];
    rdfs:comment
        "This is the default annotation for the Project arcpro tool to be used when an algebra expression is not possible to produce.";
    cct:expression "".
