@prefix : <https://quangis.github.io/vocab/tool#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix abstr: <https://quangis.github.io/tool/abstract#> .
@prefix multi: <https://quangis.github.io/tool/multi#> .
@prefix arcgis: <https://quangis.github.io/tool#> .
@prefix ccd: <http://geographicknowledge.de/vocab/CoreConceptData.rdf#> .
@prefix cct: <https://quangis.github.io/vocab/cct#> .

abstr:AddObjectVectorRegionArea a :Abstraction ;
    rdfs:comment "Adds an area attribute to an object vector region layer." ;
    cct:expression """
        1: ObjectInfo(Nom);
        join_attr
            (get_attrL 1)
            (apply1
                (compose size deify)
                (get_attrL 1)
            )
        """ ;
    :input [ a ccd:ObjectQ,
                ccd:VectorRegionA ;
            :id "1" ] ;
    :output [ a ccd:ERA,
                ccd:ObjectQ,
                ccd:VectorRegionA ] .

abstr:Aspect a :Abstraction ;
    rdfs:comment "Derives the aspect of a digital elevation model" ;
    cct:expression "aspect (1: Field(Itv))" ;
    :input [ a ccd:FieldRaster,
                ccd:IntervalA ;
            :id "1" ] ;
    :output [ a ccd:FieldRaster,
                ccd:RatioA ] .

abstr:BuildNetwork a :Abstraction ;
    rdfs:comment "Builds ratio network from line objects." ;
    cct:expression "nbuild (1: ObjectInfo(Ratio))" ;
    :input [ a ccd:LineA,
                ccd:ObjectQ,
                ccd:RatioA ;
            :id "1" ] ;
    :output [ a ccd:LineA,
                ccd:NetworkQ,
                ccd:RatioA ] .

abstr:CalculateCountAmountRatio a :Abstraction ;
    rdfs:comment "Calculates the ratio of two count vector amounts.",
        "object Content proportion OA/OA" ;
    cct:expression "apply2 ratio (1: Amounts(Ratio)) (2: Amounts(Ratio))" ;
    :implementation multi:CalculateAreaMeasure ;
    :input [ a ccd:AmountQ,
                ccd:CountA,
                ccd:VectorRegionA ;
            :id "1" ],
        [ a ccd:AmountQ,
                ccd:CountA,
                ccd:VectorRegionA ;
            :id "2" ] ;
    :output [ a ccd:AmountQ,
                ccd:IRA,
                ccd:VectorRegionA ] .

abstr:CalculateObjectAttrRatio a :Abstraction ;
    rdfs:comment "<https://pro.arcgis.com/en/pro-app/tool-reference/data-management/calculate-field.htm>",
        "Calculates ratios of two ratio scaled object attributes." ;
    cct:expression """
        1: ObjectInfo(Ratio);
        2: ObjectInfo(Ratio);
        join_attr
            (get_attrL 1)
            (apply2 ratio (get_attrR 1) (get_attrR 2))
        """ ;
    :implementation multi:CalculateAreaMeasure ;
    :input [ a ccd:ERA,
                ccd:ObjectQ,
                ccd:VectorRegionA ;
            :id "2" ],
        [ a ccd:ERA,
                ccd:ObjectQ,
                ccd:VectorRegionA ;
            :id "1" ] ;
    :output [ a ccd:IRA,
                ccd:ObjectQ,
                ccd:VectorRegionA ] .

abstr:CalculateObjectSpatialAmount a :Abstraction ;
    rdfs:comment "Calculates an amount from an object ratio quality (representating an intensive measure) using the object's area. For example, the amount of radiation falling on a building using the mean radiation and the building's area" ;
    cct:expression """
        1: ObjectInfo(Ratio);
        join_attr
            (get_attrL 1)
            (apply2 product
                (get_attrR 1)
                (apply1 (compose size deify) (get_attrL 1))
            )
        """ ;
    :implementation multi:AddandCalculateAttribute ;
    :input [ a ccd:IRA,
                ccd:ObjectQ,
                ccd:VectorRegionA ;
            :id "1" ] ;
    :output [ a ccd:ERA,
                ccd:ObjectQ,
                ccd:VectorRegionA ] .

abstr:CalculateObjectVectorCountAmountRatio a :Abstraction ;
    rdfs:comment "Calculate new attribute: Object Content proportion OA/OA",
        "Calculates the ratio of two count vector amounts on objects." ;
    cct:expression """
        1: ObjectInfo(Count);
        2: ObjectInfo(Count);
        join_attr
            (get_attrL 1)
            (apply2 ratio (get_attrR 1) (get_attrR 2))
        """ ;
    :implementation multi:CalculateAreaMeasure ;
    :input [ a ccd:CountA,
                ccd:ObjectQ,
                ccd:VectorRegionA ;
            :id "2" ],
        [ a ccd:CountA,
                ccd:ObjectQ,
                ccd:VectorRegionA ;
            :id "1" ] ;
    :output [ a ccd:IRA,
                ccd:ObjectQ,
                ccd:VectorRegionA ] .

abstr:CalculatePartialAmountsfromObjects a :Abstraction ;
    rdfs:comment "Clips some object vector with some count amounts to the extent of a field layer (e.g. a buffer) and interpolates partial count amounts R(Reg, Ratio) based on area percentage." ;
    cct:expression """
        1: ObjectInfo(Count);
        2: Field(Bool);
        arealinterpol
            (getamounts 1)
            (pi2 (groupbyR reify (select eq (loTopo
                (fcover 2 (nest true))
                (get_attrL 1)
            ) in)))
        """ ;
    :implementation multi:CalculatePartialAmounts ;
    :input [ a ccd:BooleanA,
                ccd:FieldQ,
                ccd:VectorRegionA ;
            :id "2" ],
        [ a ccd:CountA,
                ccd:ObjectQ,
                ccd:VectorRegionA ;
            :id "1" ] ;
    :output [ a ccd:AmountQ,
                ccd:CountA,
                ccd:VectorRegionA ] .

abstr:CalculateProd a :Abstraction ;
    rdfs:comment "Calculates some product of ratio scaled object attribute with some ratio value." ;
    cct:expression """
        1: ObjectInfo(Ratio);
        join_attr
            (get_attrL 1)
            (apply1 (product (-: Ratio)) (get_attrR 1))
        """ ;
    :implementation multi:AddandCalculateAttribute ;
    :input [ a ccd:ObjectQ,
                ccd:RatioA,
                ccd:VectorRegionA ;
            :id "1" ] ;
    :output [ a ccd:ObjectQ,
                ccd:RatioA,
                ccd:VectorRegionA ] .

abstr:CalculateProdPointObjects a :Abstraction ;
    rdfs:comment "Calculates a product from an attribute using some constant (e.g. time from distance using speed constant)" ;
    cct:expression """
        1: ObjectInfo(Ratio);
        join_attr
            (get_attrL 1)
            (apply1 (product (-: Ratio)) (get_attrR 1))
        """ ;
    :implementation multi:AddandCalculateAttribute ;
    :input [ a ccd:ERA,
                ccd:ObjectQ,
                ccd:PointA ;
            :id "1" ] ;
    :output [ a ccd:ERA,
                ccd:ObjectQ,
                ccd:PointA ] .

abstr:CalculateVectorFieldAreaPercentage a :Abstraction ;
    rdfs:comment "Calculates an area ratio (amount) of the size of the extent of the second boolean field with respect to the extent of the first boolean field, both represented by vector layers.",
        "Substance Coverage proportions SC/SC",
        "The assumption is here is that fields are represented by single polygons and area measures are implicitly added. The area measure of the second layer is manually taken over into the calculation. The result is a single measure, though stored into a table with a single polygon." ;
    cct:expression """
        nest2 true (ratio
            (size (fcover (1: Field(Bool)) (nest true)))
            (size (fcover (2: Field(Bool)) (nest true)))
        )
        """ ;
    :implementation multi:CalculateAreaMeasure ;
    :input [ a ccd:BooleanA,
                ccd:FieldQ,
                ccd:VectorRegionA ;
            :id "1" ],
        [ a ccd:BooleanA,
                ccd:FieldQ,
                ccd:VectorRegionA ;
            :id "2" ] ;
    :output [ a ccd:AmountQ,
                ccd:IRA,
                ccd:VectorRegionA ] .

abstr:CalculateVectorFieldPartialArea a :Abstraction ;
    rdfs:comment "Calculates a partial area measure by multiplying an area proportion with the size of the extent of a vector field.",
        "Substance Coverage SC" ;
    cct:expression "apply1 (product (size (pi1 (1: Field(Nom))))) (2: R2(Bool, Ratio))" ;
    :implementation multi:CalculateAreaMeasure ;
    :input [ a ccd:FieldQ,
                ccd:VectorRegionA ;
            rdfs:comment "field whose extent is interpreted as a Substance Coverage SC" ;
            :id "1" ],
        [ a ccd:AmountQ,
                ccd:IRA,
                ccd:VectorRegionA ;
            rdfs:comment "Substance Coverage proportion SC/SC" ;
            :id "2" ] ;
    :output [ a ccd:AmountQ,
                ccd:ERA,
                ccd:VectorRegionA ] .

abstr:ClipBoolFieldVector2Extent a :Abstraction ;
    rdfs:comment "Clips some boolean field vector to the region where a boolean field vector is true." ;
    cct:expression "subset (1: Field(Bool)) (fcover (2: Field(Bool)) (nest true))" ;
    :implementation arcgis:Clip ;
    :input [ a ccd:BooleanA,
                ccd:FieldQ,
                ccd:VectorRegionA ;
            :id "2" ],
        [ a ccd:BooleanA,
                ccd:FieldQ,
                ccd:VectorRegionA ;
            :id "1" ] ;
    :output [ a ccd:BooleanA,
                ccd:FieldQ,
                ccd:VectorRegionA ] .

abstr:ClipFieldRaster2ObjectExtent a :Abstraction ;
    rdfs:comment "Clips some interval scaled field raster to the extent of an object layer." ;
    cct:expression """
        1: Field(Ord);
        2: ObjectInfo(Nom);
        subset 1 (deify (ocover
            (get_attrL 2)
            (pi1 (get_attrL 2))
        ))
        """ ;
    :implementation arcgis:Clip ;
    :input [ a ccd:ObjectVector ;
            :id "2" ],
        [ a ccd:FieldRaster,
                ccd:OrdinalA ;
            :id "1" ] ;
    :output [ a ccd:FieldRaster,
                ccd:OrdinalA ] .

abstr:ClipNomFieldVector2Extent a :Abstraction ;
    rdfs:comment "Clips some nominal field vector to the region where a boolean field vector is true." ;
    cct:expression "subset (1: Field(Nom)) (fcover (2: Field(Bool)) (nest true))" ;
    :implementation arcgis:Clip ;
    :input [ a ccd:BooleanA,
                ccd:FieldQ,
                ccd:VectorRegionA ;
            :id "2" ],
        [ a ccd:FieldQ,
                ccd:VectorRegionA ;
            :id "1" ] ;
    :output [ a ccd:FieldQ,
                ccd:VectorRegionA ] .

abstr:ClipObject2Object a :Abstraction ;
    rdfs:comment "Clips some object polygons to the extent of an object layer. We assume here that objects exactly coincide (otherwise clip would cut objects)." ;
    cct:expression """
        1: ObjectInfo(Count);
        2: ObjectInfo(Nom);
        subset
            1
            (pi1 (select eq
                (oTopo (get_attrL 1) (get_attrL 2))
                in
            ))
        """ ;
    :implementation arcgis:Clip ;
    :input [ a ccd:ObjectQ,
                ccd:PlainVectorRegionA ;
            rdfs:comment "to the regions of these objects" ;
            :id "2" ],
        [ a ccd:CountA,
                ccd:ObjectQ,
                ccd:PlainVectorRegionA ;
            rdfs:comment "objects to be clipped" ;
            :id "1" ] ;
    :output [ a ccd:CountA,
                ccd:ObjectQ,
                ccd:PlainVectorRegionA ] .

abstr:ClosestFacilityAnalysis a :Abstraction ;
    rdfs:comment "Selects the distance to the closest goal object on a line network." ;
    cct:expression """
        1: Network(Ratio);
        2: ObjectInfo(Nom);
        3: ObjectInfo(Nom);
        join_attr
            (get_attrL 2)
            (groupbyL min (nDist (get_attrL 2) (get_attrL 3) 1))
        """ ;
    :input [ a ccd:LineA,
                ccd:NetworkQ,
                ccd:RatioA ;
            rdfs:comment "roads" ;
            :id "1" ],
        [ a ccd:ObjectQ,
                ccd:PointA ;
            rdfs:comment "goals" ;
            :id "2" ],
        [ a ccd:ObjectQ,
                ccd:PointA ;
            rdfs:comment "origins" ;
            :id "3" ] ;
    :output [ a ccd:ObjectQ,
                ccd:PointA,
                ccd:RatioA ] .

abstr:ContourToFieldRaster a :Abstraction ;
    rdfs:comment "Converts contour maps to field Rasters" ;
    cct:expression "revert (1: Contour)" ;
    :implementation arcgis:PolygonToRaster ;
    :input [ a ccd:Contour ;
            :id "1" ] ;
    :output [ a ccd:FieldRaster,
                ccd:PlainOrdinalA ] .

abstr:CoverageToNominalFieldRaster a :Abstraction ;
    rdfs:comment "Converts Field polygons to nominal field Rasters" ;
    cct:expression "revert (1: Coverages(Nom))" ;
    :implementation arcgis:PolygonToRaster ;
    :input [ a ccd:Coverage,
                ccd:PlainNominalA ;
            :id "1" ] ;
    :output [ a ccd:FieldRaster,
                ccd:PlainNominalA ] .

abstr:CreateUnitHydrograph a :Abstraction ;
    rdfs:comment "Creates a unit hydrograph from an isochrones raster based on isochrone interval. This is a table that indicates for each time interval an areal coverage" ;
    cct:expression """
        apply1 ((swap ratio) (-: Ratio)) (groupby size (1: Field(Ord)))
        """ ;
    :implementation multi:RasterCoverage ;
    :input [ a ccd:FieldRaster,
                ccd:OrdinalA ;
            :id "1" ] ;
    :output [ a ccd:AmountQ,
                ccd:LayerA,
                ccd:RatioA ] .

abstr:EraseFieldExtentfromFieldVector a :Abstraction ;
    rdfs:comment "Erases the coverage of a boolean field vector (second input) from a field vector (first input)" ;
    cct:expression """
        1: Field(Nom);
        2: Field(Bool);
        subset
            1
            (pi1 (select
                eq
                (lTopo (pi1 1) (reify (fcover 2 (nest true))))
                out
            ))
        """ ;
    :implementation arcgis:Erase ;
    :input [ a ccd:BooleanA,
                ccd:FieldQ,
                ccd:VectorRegionA ;
            :id "2" ],
        [ a ccd:FieldQ,
                ccd:PlainVectorRegionA ;
            :id "1" ] ;
    :output [ a ccd:FieldQ,
                ccd:PlainVectorRegionA ] .

abstr:ExtractByMask a :Abstraction ;
    rdfs:comment "Extract raster by the extent of another (field) raster." ;
    cct:expression "subset (1: Field(Loc)) (pi1 (2: Field(Nom)))" ;
    :implementation arcgis:ExtractByMask ;
    :input [ a ccd:FieldRaster ;
            :id "2" ],
        [ a ccd:FieldRaster,
                ccd:RatioA ;
            rdfs:comment "Flow directions by watershed mask" ;
            :id "1" ] ;
    :output [ a ccd:FieldRaster,
                ccd:RatioA ] .

abstr:FC2FCObjectTess a :Abstraction ;
    rdfs:comment "Object selection variant by id." ;
    cct:expression """
        subset (1: ObjectInfo(Nom)) (-: C(Obj))
        """ ;
    :implementation arcgis:FC2FC ;
    :input [ a ccd:ObjectQ,
                ccd:VectorTessellationA ;
            :id "1" ] ;
    :output [ a ccd:ObjectQ,
                ccd:PlainVectorRegionA ] .

abstr:FlowAccumulation a :Abstraction ;
    rdfs:comment "Accumulates flow directions into areas reachable downstream." ;
    cct:expression "apply1 size (accumulate (1: Field(Loc)))" ;
    :implementation arcgis:FlowAccumulation ;
    :input [ a ccd:CyclicA,
                ccd:FieldRaster ;
            rdfs:comment "Needs to be a direction" ;
            :id "1" ] ;
    :output [ a ccd:FieldRaster,
                ccd:RatioA ] .

abstr:FlowDirection a :Abstraction ;
    rdfs:comment "Computes a grid graph of flow directions from a DEM." ;
    cct:expression "flowdirgraph (1: Field(Itv))" ;
    :implementation arcgis:FlowDirection ;
    :input [ a ccd:FieldRaster,
                ccd:IntervalA ;
            rdfs:comment "DEM" ;
            :id "1" ] ;
    :output [ a ccd:CyclicA,
                ccd:FieldRaster ] .

abstr:FlowLength a :Abstraction ;
    rdfs:comment "Calculate the upstream or downstream distance, or weighted distance (=time), along the flow path for each cell." ;
    cct:expression """
        1: Field(Ratio);
        2: Field(Loc);
        groupbyL max (relunion (pi2 (apply2
            (lgDist (gridgraph 2 1))
            (apply nest (pi1 2)) (accumulate 2)
        )))
        """ ;
    :implementation arcgis:FlowLength ;
    :input [ a ccd:FieldRaster,
                ccd:RatioA ;
            rdfs:comment "Impedance Weight raster (e.g. 1/velocity raster)" ;
            :id "1" ],
        [ a ccd:FieldRaster,
                ccd:RatioA ;
            rdfs:comment "Flow direction raster;" ;
            :id "2" ] ;
    :output [ a ccd:FieldRaster,
                ccd:RatioA ;
            rdfs:comment "Flow time raster" ] .

abstr:IDWInterval a :Abstraction ;
    rdfs:comment "Standard point interpolation for interval measurements." ;
    cct:expression "interpol (1: PointMeasures) (deify (-: Reg))" ;
    :implementation arcgis:IDWInterval ;
    :input [ a ccd:IntervalA,
                ccd:PointMeasures ;
            :id "1" ] ;
    :output [ a ccd:FieldRaster,
                ccd:IntervalA ] .

abstr:IntersectDissolveField2Object a :Abstraction ;
    rdfs:comment "Coverage of vector field in object",
        "Intersects a field vector with an object vector and then dissolves the result into the object to measure the areal coverage of the field inside the object." ;
    cct:expression """
        1: Field(Nom);
        2: ObjectInfo(_);
        join_attr
            (get_attrL 2)
            (groupbyR size (select eq (loTopo
                (fcover 1 (-: C(Nom)))
                (get_attrL 2)
            ) in))
        """ ;
    :implementation multi:IntersectDissolve ;
    :input [ a ccd:FieldQ,
                ccd:VectorRegionA ;
            :id "1" ],
        [ a ccd:ObjectQ,
                ccd:VectorRegionA ;
            :id "2" ] ;
    :output [ a ccd:ERA,
                ccd:ObjectQ,
                ccd:VectorRegionA ] .

abstr:KrigingInterval a :Abstraction ;
    rdfs:comment "Kriging point interpolation for interval measurements." ;
    cct:expression "interpol (1: PointMeasures) (deify (-: Reg))" ;
    :implementation arcgis:KrigingInterval ;
    :input [ a ccd:IntervalA,
                ccd:PointMeasures ;
            :id "1" ] ;
    :output [ a ccd:FieldRaster,
                ccd:IntervalA ] .

abstr:LoadAmountonObjects a :Abstraction ;
    rdfs:comment "Loads object based count amounts from excel and joins them with vector objects." ;
    cct:expression """
        1: R2(Obj, Count);
        2: ObjectInfo(_);
        join_attr (get_attrL 2) 1
        """ ;
    :implementation multi:JoinFromTable ;
    :input [ a ccd:ObjectQ,
                ccd:VectorRegionA ;
            :id "2" ],
        [ a ccd:CountA,
                ccd:ObjectQ ;
            :id "1" ] ;
    :output [ a ccd:CountA,
                ccd:ObjectQ,
                ccd:VectorRegionA ] .

abstr:LocalMapAlgebraDivide a :Abstraction ;
    rdfs:comment "Builds and executes a Local Map Algebra expression that divides rasters by a ratio number" ;
    cct:expression "apply1 ((swap ratio) (-: Ratio)) (1: Field(Ratio))" ;
    :implementation arcgis:RasterCalculator ;
    :input [ a ccd:FieldRaster,
                ccd:RatioA ;
            :id "1" ] ;
    :output [ a ccd:FieldRaster,
                ccd:RatioA ] .

abstr:LocalMapAlgebraInvert a :Abstraction ;
    rdfs:comment "Builds and executes a Local Map Algebra expression that inverts rasters with a ratio level." ;
    cct:expression "apply1 (ratio (-: Ratio)) (1: Field(Ratio))" ;
    :implementation arcgis:RasterCalculator ;
    :input [ a ccd:FieldRaster,
                ccd:RatioA ;
            :id "1" ] ;
    :output [ a ccd:FieldRaster,
                ccd:RatioA ] .

abstr:LocalMapAlgebraSubOrder a :Abstraction ;
    rdfs:comment "Builds and executes a Local Map Algebra expression (smaller than or greater than some number) using Python syntax using rasters with an ordinal level",
        "local map algebra with only a single input layer" ;
    cct:expression "select (compose2 notj leq) (1: Field(Ord)) (-: Ord)" ;
    :implementation arcgis:RasterCalculator ;
    :input [ a ccd:FieldRaster,
                ccd:OrdinalA ;
            :id "1" ] ;
    :output [ a ccd:FieldRaster,
                ccd:OrdinalA ] .

abstr:LocalMapAlgebraSubRatio a :Abstraction ;
    rdfs:comment "Builds and executes a Local Map Algebra expression (less than or equal to some number) using Python syntax using rasters with a ratio level",
        "local map algebra transformation with ratio field" ;
    cct:expression "select (compose2 notj leq) (1: Field(Ratio)) (-: Ratio)" ;
    :implementation arcgis:RasterCalculator ;
    :input [ a ccd:FieldRaster,
                ccd:RatioA ;
            :id "1" ] ;
    :output [ a ccd:FieldRaster,
                ccd:RatioA ] .

abstr:MakePointMeasuresFromTable a :Abstraction ;
    rdfs:comment "Makes a layer of pointmeasures from some XY table." ;
    cct:expression "1: PointMeasures" ;
    :implementation multi:MakeLayerFromTable ;
    :input [ a ccd:IntervalA,
                ccd:PointMeasures ;
            :id "1" ] ;
    :output [ a ccd:IntervalA,
                ccd:PointMeasures ] .

abstr:MergeObjects a :Abstraction ;
    rdfs:comment "Merges object parts into single objects based on object identifiers stored as names." ;
    cct:expression """
        1: ObjectInfo(Nom);
        join_attr
            (groupby
                (compose merge (compose pi2 (subset (get_attrL 1))))
                (apply1 objectify (get_attrR 1))
            )
            (getobjectnames (pi2 (get_attrR 1)))
        """ ;
    :implementation arcgis:Dissolve ;
    :input [ a ccd:NominalA,
                ccd:ObjectQ,
                ccd:VectorTessellationA ;
            :id "1" ] ;
    :output [ a ccd:NominalA,
                ccd:ObjectQ,
                ccd:VectorTessellationA ] .

abstr:NearPointObjects a :Abstraction ;
    rdfs:comment "Near tool, to seach for the closest objects using Euclidean distance." ;
    cct:expression """
        1: ObjectInfo(Nom);
        2: ObjectInfo(Nom);
        join_attr
            (get_attrL 1)
            (groupbyL min (oDist (get_attrL 1) (get_attrL 2)))
        """ ;
    :implementation arcgis:NearPointObjects ;
    :input [ a ccd:ObjectQ,
                ccd:PointA ;
            :id "2" ],
        [ a ccd:ObjectQ,
                ccd:PointA ;
            :id "1" ] ;
    :output [ a ccd:ObjectQ,
                ccd:PointA,
                ccd:RatioA ] .

abstr:ObjectBuffer a :Abstraction ;
    rdfs:comment "Buffers some object vector and returns the buffer as a boolean field R(Loc, Bool)" ;
    cct:expression "extrapol (get_attrL (1: ObjectInfo(Nom)))" ;
    :input [ a ccd:ObjectQ,
                ccd:VectorA ;
            :id "1" ] ;
    :output [ a ccd:BooleanA,
                ccd:FieldQ,
                ccd:PlainVectorRegionA ] .

abstr:ObjectSummaryStatisticsAmount a :Abstraction ;
    rdfs:comment "Sums the amount values of an object layer into a sum" ;
    cct:expression "contentsum (getamounts (1: ObjectInfo(Ratio)))" ;
    :implementation arcgis:SummaryStatistics ;
    :input [ a ccd:CountA,
                ccd:ObjectQ,
                ccd:VectorRegionA ;
            :id "1" ] ;
    :output [ a ccd:AmountQ,
                ccd:CountA,
                ccd:VectorRegionA ] .

abstr:RasterToContourInterval a :Abstraction ;
    rdfs:comment "Converts a field raster to a Contour dataset. The raster is first reclassified to an ordinal raster, and then converted to a polygon layer." ;
    cct:expression "invert (apply1 classify (1: Field(Itv)))" ;
    :implementation multi:RasterToContour ;
    :input [ a ccd:FieldRaster,
                ccd:IntervalA ;
            :id "1" ] ;
    :output [ a ccd:Contour,
                ccd:PlainOrdinalA ] .

abstr:RasterToIsoRaster a :Abstraction ;
    rdfs:comment "Converts an interval field raster into an ordinal raster." ;
    cct:expression "apply1 classify (1: Field(Itv))" ;
    :implementation arcgis:RasterToIsoRaster ;
    :input [ a ccd:FieldRaster,
                ccd:IntervalA ;
            :id "1" ] ;
    :output [ a ccd:FieldRaster,
                ccd:PlainOrdinalA ] .

abstr:RegionFromRasterExtent a :Abstraction ;
    rdfs:comment "Make a region layer from the extent of a raster. Measures the coverage of a nominal field." ;
    cct:expression """
        1: Field(Nom);
        nest2 (name (pi2 1)) (reify (fcover 1 (pi2 1)))
        """ ;
    :implementation arcgis:RegionFromRasterExtent ;
    :input [ a ccd:FieldRaster,
                ccd:NominalA ;
            :id "1" ] ;
    :output [ a ccd:AmountQ,
                ccd:NominalA,
                ccd:VectorRegionA ] .

abstr:SelectFeaturesByObjectPlainRegionObjects a :Abstraction ;
    rdfs:comment "Select region objects by id" ;
    cct:expression "subset (1: ObjectInfo(Nom)) (-: C(Obj))" ;
    :implementation multi:FullSelectFeatures ;
    :input [ a ccd:ObjectQ,
                ccd:PlainVectorRegionA ;
            :id "1" ] ;
    :output [ a ccd:ObjectQ,
                ccd:PlainVectorRegionA ] .

abstr:SelectFeaturesCoverageToExistenceVector a :Abstraction ;
    rdfs:comment "Select patches of a coverage by attribute" ;
    cct:expression "revert (select eq (invert (1: Field(Itv)): Coverages(Nom)) (-: Nom))" ;
    :implementation multi:FullSelectFeatures ;
    :input [ a ccd:Coverage ;
            :id "1" ] ;
    :output [ a ccd:FieldQ,
                ccd:PlainVectorRegionA ] .

abstr:SelectLayerByAttributeLineObjects a :Abstraction ;
    cct:expression "subset (1: ObjectInfo(Nom)) (-: C(Nom))" ;
    :implementation multi:FullSelectLayerByAttribute ;
    :input [ a ccd:LineA,
                ccd:NominalA,
                ccd:ObjectQ ;
            :id "1" ] ;
    :output [ a ccd:LineA,
                ccd:NominalA,
                ccd:ObjectQ ] .

abstr:SelectLayerByAttributePlainRegionObjects a :Abstraction ;
    cct:expression "subset (1: ObjectInfo(Nom)) (-: C(Nom))" ;
    :implementation multi:FullSelectLayerByAttribute ;
    :input [ a ccd:NominalA,
                ccd:ObjectQ,
                ccd:PlainVectorRegionA ;
            :id "1" ] ;
    :output [ a ccd:NominalA,
                ccd:ObjectQ,
                ccd:PlainVectorRegionA ] .

abstr:SelectLayerByAttributePointObjects a :Abstraction ;
    cct:expression "subset (1: ObjectInfo(Nom)) (-: C(Nom))" ;
    :implementation multi:FullSelectLayerByAttribute ;
    :input [ a ccd:NominalA,
                ccd:ObjectQ,
                ccd:PointA ;
            :id "1" ] ;
    :output [ a ccd:NominalA,
                ccd:ObjectQ,
                ccd:PointA ] .

abstr:SelectLayerByAttributeTessObjects a :Abstraction ;
    cct:expression "subset (1: ObjectInfo(Nom)) (-: C(Nom))" ;
    :implementation multi:FullSelectLayerByAttribute ;
    :input [ a ccd:NominalA,
                ccd:ObjectQ,
                ccd:VectorTessellationA ;
            :id "1" ] ;
    :output [ a ccd:NominalA,
                ccd:ObjectQ,
                ccd:PlainVectorRegionA ] .

abstr:SelectLayerByLocationLineObjects a :Abstraction ;
    cct:expression """
        1: ObjectInfo(Nom);
        2: ObjectInfo(Nom);
        subset
            1
            (pi1 (select
                eq
                (oTopo (get_attrL 1) (get_attrL 2))
                in
            ))
        """ ;
    :implementation multi:FullSelectLayerByLocation ;
    :input [ a ccd:LineA,
                ccd:ObjectQ ;
            :id "1" ],
        [ a ccd:ObjectQ,
                ccd:VectorA ;
            :id "2" ] ;
    :output [ a ccd:LineA,
                ccd:ObjectQ ] .

abstr:SelectLayerByLocationPlainRegionObjects a :Abstraction ;
    cct:expression """
        1: ObjectInfo(Nom);
        2: ObjectInfo(Nom);
        subset
            1
            (pi1 (select
                eq
                (oTopo (get_attrL 1) (get_attrL 2))
                in
            ))
        """ ;
    :implementation multi:FullSelectLayerByLocation ;
    :input [ a ccd:ObjectQ,
                ccd:PlainVectorRegionA ;
            :id "1" ],
        [ a ccd:ObjectQ,
                ccd:VectorA ;
            :id "2" ] ;
    :output [ a ccd:ObjectQ,
                ccd:PlainVectorRegionA ] .

abstr:SelectLayerByLocationPlainRegionObjectsDist a :Abstraction ;
    rdfs:comment "Object selection variant with distance" ;
    cct:expression """
        1: ObjectInfo(Nom);
        2: ObjectInfo(Nom);
        subset
            1
            (pi1 (select
                leq
                (oDist (get_attrL 1) (get_attrL 2))
                (-: Ratio)
            ))
        """ ;
    :implementation multi:FullSelectLayerByLocation ;
    :input [ a ccd:ObjectQ,
                ccd:VectorA ;
            :id "2" ],
        [ a ccd:ObjectQ,
                ccd:PlainVectorRegionA ;
            :id "1" ] ;
    :output [ a ccd:ObjectQ,
                ccd:PlainVectorRegionA ] .

abstr:SelectLayerByLocationPlainRegionObjectsFieldDist a :Abstraction ;
    rdfs:comment "Object selection variant with vector field patches" ;
    cct:expression """
        1: ObjectInfo(Nom);
        2: Field(Nom);
        subset
            1
            (pi3 (select
                eq
                (loTopo (pi1 2) (get_attrL 1))
                in
            ))
        """ ;
    :implementation multi:FullSelectLayerByLocation ;
    :input [ a ccd:ObjectQ,
                ccd:PlainVectorRegionA ;
            :id "1" ],
        [ a ccd:FieldQ,
                ccd:VectorRegionA ;
            :id "2" ] ;
    :output [ a ccd:ObjectQ,
                ccd:PlainVectorRegionA ] .

abstr:SelectLayerByLocationPointObjects a :Abstraction ;
    cct:expression """
        1: ObjectInfo(Nom);
        2: ObjectInfo(Nom);
        subset
            1
            (pi1 (select
                eq
                (oTopo (get_attrL 1) (get_attrL 2))
                in
            ))
        """ ;
    :implementation multi:FullSelectLayerByLocation ;
    :input [ a ccd:ObjectQ,
                ccd:VectorA ;
            :id "2" ],
        [ a ccd:ObjectQ,
                ccd:PointA ;
            :id "1" ] ;
    :output [ a ccd:ObjectQ,
                ccd:PointA ] .

abstr:SelectLayerByLocationTessObjects a :Abstraction ;
    cct:expression """
        1: ObjectInfo(Nom);
        2: ObjectInfo(Nom);
        subset
            1
            (pi1 (select
                eq
                (oTopo (get_attrL 1) (get_attrL 2))
                in
            ))
        """ ;
    :implementation multi:FullSelectLayerByLocation ;
    :input [ a ccd:ObjectQ,
                ccd:VectorTessellationA ;
            :id "1" ],
        [ a ccd:ObjectQ,
                ccd:VectorA ;
            :id "2" ] ;
    :output [ a ccd:ObjectQ,
                ccd:VectorTessellationA ] .

abstr:SelectLayerByObjectLineObjects a :Abstraction ;
    cct:expression "subset (1: ObjectInfo(Nom)) (-: C(Obj))" ;
    :implementation multi:FullSelectLayerByAttribute ;
    :input [ a ccd:LineA,
                ccd:ObjectQ ;
            :id "1" ] ;
    :output [ a ccd:BooleanA,
                ccd:LineA,
                ccd:ObjectQ ] .

abstr:SelectLayerByObjectPlainRegionObjects a :Abstraction ;
    cct:expression "subset (1: ObjectInfo(Nom)) (-: C(Obj))" ;
    :implementation multi:FullSelectLayerByAttribute ;
    :input [ a ccd:ObjectQ,
                ccd:PlainVectorRegionA ;
            :id "1" ] ;
    :output [ a ccd:BooleanA,
                ccd:ObjectQ,
                ccd:PlainVectorRegionA ] .

abstr:SelectLayerByObjectPointObjects a :Abstraction ;
    cct:expression "subset (1: ObjectInfo(Nom)) (-: C(Obj))" ;
    :implementation multi:FullSelectLayerByAttribute ;
    :input [ a ccd:ObjectQ,
                ccd:PointA ;
            :id "1" ] ;
    :output [ a ccd:BooleanA,
                ccd:ObjectQ,
                ccd:PointA ] .

abstr:SelectLayerByObjectTessObjects a :Abstraction ;
    cct:expression "subset (1: ObjectInfo(Nom)) (-: C(Obj))" ;
    :implementation multi:FullSelectLayerByAttribute ;
    :input [ a ccd:ObjectQ,
                ccd:VectorTessellationA ;
            :id "1" ] ;
    :output [ a ccd:BooleanA,
                ccd:ObjectQ,
                ccd:PlainVectorRegionA ] .

abstr:SelectLayerByRatioGEQPlainRegionObjects a :Abstraction ;
    rdfs:comment "Object selection variant vith gteq, needs a ratio attribute" ;
    cct:expression "select (compose2 notj leq) (1: ObjectInfo(Ratio)) (-: Ratio)" ;
    :implementation multi:FullSelectLayerByAttribute ;
    :input [ a ccd:ObjectQ,
                ccd:PlainVectorRegionA,
                ccd:RatioA ;
            :id "1" ] ;
    :output [ a ccd:ObjectQ,
                ccd:PlainVectorRegionA,
                ccd:RatioA ] .

abstr:SelectLayerByRatioLineObjects a :Abstraction ;
    cct:expression "subset (1: ObjectInfo(Ratio)) (-: C(Ratio))" ;
    :implementation multi:FullSelectLayerByAttribute ;
    :input [ a ccd:LineA,
                ccd:ObjectQ,
                ccd:RatioA ;
            :id "1" ] ;
    :output [ a ccd:LineA,
                ccd:ObjectQ,
                ccd:RatioA ] .

abstr:SelectLayerByRatioPlainRegionObjects a :Abstraction ;
    cct:expression "subset (1: ObjectInfo(Ratio)) (-: C(Ratio))" ;
    :implementation multi:FullSelectLayerByAttribute ;
    :input [ a ccd:ObjectQ,
                ccd:PlainVectorRegionA,
                ccd:RatioA ;
            :id "1" ] ;
    :output [ a ccd:ObjectQ,
                ccd:PlainVectorRegionA,
                ccd:RatioA ] .

abstr:SelectLayerByRatioPointObjects a :Abstraction ;
    cct:expression "subset (1: ObjectInfo(Ratio)) (-: C(Ratio))" ;
    :implementation multi:FullSelectLayerByAttribute ;
    :input [ a ccd:ObjectQ,
                ccd:PointA,
                ccd:RatioA ;
            :id "1" ] ;
    :output [ a ccd:ObjectQ,
                ccd:PointA,
                ccd:RatioA ] .

abstr:SelectLayerByRatioTessObjects a :Abstraction ;
    cct:expression "subset (1: ObjectInfo(Ratio)) (-: C(Ratio))" ;
    :implementation multi:FullSelectLayerByAttribute ;
    :input [ a ccd:ObjectQ,
                ccd:RatioA,
                ccd:VectorTessellationA ;
            :id "1" ] ;
    :output [ a ccd:ObjectQ,
                ccd:PlainVectorRegionA,
                ccd:RatioA ] .

abstr:SelectLayerContourToExistenceVector a :Abstraction ;
    rdfs:comment "Contour to Existence Vector (select a contour map greater than some ordinal value)" ;
    cct:expression "revert (select (compose2 notj leq) (1: Contour) (-: Ord))" ;
    :implementation multi:FullSelectLayerByAttribute ;
    :input [ a ccd:FieldQ,
                ccd:OrdinalA,
                ccd:VectorTessellationA ;
            rdfs:comment "Contour is a coverage that is a subclass of coverage and ordinalA, and therefore also allows field rasters, which we don't want in this context." ;
            :id "1" ] ;
    :output [ a ccd:FieldQ,
                ccd:OrdinalA,
                ccd:PlainVectorRegionA ] .

abstr:SelectLayerCoverageToExistenceVector a :Abstraction ;
    cct:expression "revert (select eq (1: Coverages(Nom)) (-: Nom))" ;
    :implementation multi:FullSelectLayerByAttribute ;
    :input [ a ccd:FieldQ,
                ccd:VectorTessellationA ;
            rdfs:comment "Coverage is defined as a subclass of FieldQ and TesselationA, and therefore also allows field rasters, which we don't want in this context." ;
            :id "1" ] ;
    :output [ a ccd:FieldQ,
                ccd:PlainVectorRegionA ] .

abstr:SelectObjectbyExtent a :Abstraction ;
    rdfs:comment "Select object vector by extent. Extent remains implicit." ;
    cct:expression """
        1: ObjectInfo(Nom);
        subset 1 (pi3 (select
            eq
            (loTopo (deify (-: Reg)) (get_attrL 1))
            in
        ))
        """ ;
    :implementation arcgis:SelectObjectByExtent ;
    :input [ a ccd:ObjectQ,
                ccd:VectorA ;
            :id "1" ] ;
    :output [ a ccd:ObjectQ,
                ccd:VectorA ] .

abstr:Slope a :Abstraction ;
    rdfs:comment "Computes slopes of a DEM." ;
    cct:expression "slope (1: Field(Itv))" ;
    :implementation arcgis:Slope ;
    :input [ a ccd:FieldRaster,
                ccd:IntervalA ;
            :id "1" ] ;
    :output [ a ccd:FieldRaster,
                ccd:RatioA ] .

abstr:SnapPourPoint a :Abstraction ;
    rdfs:comment "Snaps a pour point to a raster to generate a raster showing the pour point." ;
    cct:expression """
        # This is a simplification that ignores flow accumulation, but just
        # generates a nominal patch from an object nominal
        1: ObjectInfo(Nom);
        join (revert (get_attrL 1)) (get_attrR 1)
        """ ;
    :implementation arcgis:SnapPourPoint ;
    :input [ a ccd:ObjectQ,
                ccd:PointA ;
            :id "1" ],
        [ a ccd:FieldRaster,
                ccd:RatioA ;
            rdfs:comment "flow accumulation raster" ;
            :id "2" ] ;
    :output [ a ccd:FieldQ,
                ccd:PlainNominalA,
                ccd:RasterA ] .

abstr:SpatialJoinAmountSumTessCount a :Abstraction ;
    rdfs:comment "Sums the attributes at Count measurement level from one feature to another based on the spatial relation",
        "with JOIN_ONE_TO_ONE parameter, with Merge_RULe sum for Count data." ;
    cct:expression """
        1: Amounts(Count);
        2: ObjectInfo(Nom);
        join_attr
            (get_attrL 2)
            (join
                (get_attrL 2)
                (groupbyR sum (join_key
                    (select
                        eq
                        (rTopo (pi1 1) (pi2 (get_attrL 2)))
                        in
                    )
                    1
                ))
            )
        """ ;
    :implementation arcgis:SpatialJoin ;
    :input [ a ccd:ObjectQ,
                ccd:VectorTessellationA ;
            :id "2" ],
        [ a ccd:AmountQ,
                ccd:CountA,
                ccd:VectorRegionA ;
            :id "1" ] ;
    :output [ a ccd:CountA,
                ccd:ObjectQ,
                ccd:VectorTessellationA ] .

abstr:SpatialJoinAmountSumTessRatio a :Abstraction ;
    rdfs:comment "Spatial join with sum rule with vector amounts",
        "Sums the attributes at ratio measurement level from one feature to another based on the spatial relation",
        "with JOIN_ONE_TO_ONE parameter, with Merge_RULe sum for Ratio data" ;
    cct:expression """
        1: Amounts(Ratio);
        2: ObjectInfo(Nom);
        join_attr
            (get_attrL 2) (join
                (get_attrL 2)
                (groupbyR sum (join_key
                    (select
                        eq
                        (rTopo (pi1 1) (pi2 (get_attrL 2)))
                        in)
                    1
                ))
            )
        """ ;
    :implementation arcgis:SpatialJoin ;
    :input [ a ccd:AmountQ,
                ccd:ERA,
                ccd:VectorRegionA ;
            :id "1" ],
        [ a ccd:ObjectQ,
                ccd:VectorTessellationA ;
            :id "2" ] ;
    :output [ a ccd:ERA,
                ccd:ObjectQ,
                ccd:VectorTessellationA ] .

abstr:SpatialJoinCountTess a :Abstraction ;
    rdfs:comment "Counts the number of features from one feature to another based on the spatial relation",
        "spatial join with the count rule",
        "with JOIN_ONE_TO_ONE parameter and with Merge_RULe count" ;
    cct:expression """
        1: ObjectInfo(Nom);
        2: ObjectInfo(Nom);
        join_attr
            (get_attrL 2)
            (apply1
                (ocont (get_attrL 1))
                (get_attrL 2)
            )
        """ ;
    :implementation arcgis:SpatialJoin ;
    :input [ a ccd:ObjectQ,
                ccd:VectorTessellationA ;
            :id "2" ],
        [ a ccd:ObjectQ,
                ccd:VectorA ;
            :id "1" ] ;
    :output [ a ccd:CountA,
                ccd:ObjectQ,
                ccd:VectorTessellationA ] .

abstr:SpatialJoinMeanTessCount a :Abstraction ;
    rdfs:comment "Averages the attributes at Count measurement level from one feature to another based on the spatial relation",
        "with JOIN_ONE_TO_ONE parameter, with Merge_RULe mean for Count data" ;
    cct:expression """
        1: ObjectInfo(Count);
        2: ObjectInfo(Nom);
        join_attr
            (get_attrL 2)
            (join
                (get_attrL 2)
                (groupbyR avg (join_key (select eq (rTopo
                    (pi2 (get_attrL 1))
                    (pi2 (get_attrL 2))
                ) in) (getamounts 1)))
            )
        """ ;
    :implementation arcgis:SpatialJoin ;
    :input [ a ccd:ObjectQ,
                ccd:VectorTessellationA ;
            :id "2" ],
        [ a ccd:CountA,
                ccd:ObjectQ,
                ccd:VectorA ;
            :id "1" ] ;
    :output [ a ccd:CountA,
                ccd:ObjectQ,
                ccd:VectorTessellationA ] .

abstr:SpatialJoinMeanTessInterval a :Abstraction ;
    rdfs:comment "Averages the attributes at interval measurement level from one feature to another based on the spatial relation",
        "spatial join with mean rule",
        "with JOIN_ONE_TO_ONE parameter, with Merge_RULe mean for interval data" ;
    cct:expression """
        1: ObjectInfo(Ratio);
        2: ObjectInfo(Nom);
        join_attr
            (get_attrL 2)
            (join
                (get_attrL 2)
                (groupbyR avg (join_key (select eq (rTopo
                    (pi2 (get_attrL 1))
                    (pi2 (get_attrL 2))
                ) in) (getamounts 1)))
            )
        """ ;
    :implementation arcgis:SpatialJoin ;
    :input [ a ccd:IntervalA,
                ccd:ObjectQ,
                ccd:VectorA ;
            :id "1" ],
        [ a ccd:ObjectQ,
                ccd:VectorTessellationA ;
            :id "2" ] ;
    :output [ a ccd:IntervalA,
                ccd:ObjectQ,
                ccd:VectorTessellationA ] .

abstr:SpatialJoinMeanTessRatio a :Abstraction ;
    rdfs:comment "Averages the attributes at Ratio measurement level from one feature to another based on the spatial relation",
        "with JOIN_ONE_TO_ONE parameter, with Merge_RULe mean for Ratio data" ;
    cct:expression """
        1: ObjectInfo(Ratio);
        2: ObjectInfo(Nom);
        join_attr
            (get_attrL 2)
            (join
                (get_attrL 2)
                (groupbyR avg (join_key (select eq (rTopo
                    (pi2 (get_attrL 1))
                    (pi2 (get_attrL 2))
                ) in) (getamounts 1)))
            )
        """ ;
    :implementation arcgis:SpatialJoin ;
    :input [ a ccd:ObjectQ,
                ccd:VectorTessellationA ;
            :id "2" ],
        [ a ccd:ObjectQ,
                ccd:RatioA,
                ccd:VectorA ;
            :id "1" ] ;
    :output [ a ccd:ObjectQ,
                ccd:RatioA,
                ccd:VectorTessellationA ] .

abstr:SpatialJoinSumTessCount a :Abstraction ;
    rdfs:comment "Sums the attributes at Count measurement level from one feature to another based on the spatial relation",
        "with JOIN_ONE_TO_ONE parameter, with Merge_RULe sum for Count data" ;
    cct:expression """
        1: ObjectInfo(Count);
        2: ObjectInfo(Nom);
        join_attr
            (get_attrL 2)
            (join (get_attrL 2) (groupbyR sum (join_key
                (select eq (rTopo
                    (pi2 (get_attrL 1))
                    (pi2 (get_attrL 2))
                ) in)
                (getamounts 1)
            )))
        """ ;
    :implementation arcgis:SpatialJoin ;
    :input [ a ccd:ObjectQ,
                ccd:VectorTessellationA ;
            :id "2" ],
        [ a ccd:CountA,
                ccd:ObjectQ,
                ccd:VectorA ;
            :id "1" ] ;
    :output [ a ccd:CountA,
                ccd:ObjectQ,
                ccd:VectorTessellationA ] .

abstr:SpatialJoinSumTessRatio a :Abstraction ;
    rdfs:comment "Spatial join with sum rule",
        "Sums the attributes at ratio measurement level from one feature to another based on the spatial relation",
        "with JOIN_ONE_TO_ONE parameter, with Merge_RULe sum for Ratio data" ;
    cct:expression """
        1: ObjectInfo(Ratio);
        2: ObjectInfo(Nom);
        join_attr
            (get_attrL 2)
            (join (get_attrL 2) (groupbyR sum (join_key
                (select eq (rTopo
                    (pi2 (get_attrL 1))
                    (pi2 (get_attrL 2))
                ) in)
                (getamounts 1)
            )))
        """ ;
    :implementation arcgis:SpatialJoin ;
    :input [ a ccd:ERA,
                ccd:ObjectQ,
                ccd:VectorA ;
            :id "1" ],
        [ a ccd:ObjectQ,
                ccd:VectorTessellationA ;
            :id "2" ] ;
    :output [ a ccd:ERA,
                ccd:ObjectQ,
                ccd:VectorTessellationA ] .

abstr:SummaryStatisticsAmount a :Abstraction ;
    rdfs:comment "Sums the amount values of a count amount layer into a sum" ;
    cct:expression "contentsum (1: Amounts(Ratio))" ;
    :implementation arcgis:SummaryStatistics ;
    :input [ a ccd:AmountQ,
                ccd:CountA,
                ccd:VectorRegionA ;
            :id "1" ] ;
    :output [ a ccd:AmountQ,
                ccd:CountA,
                ccd:VectorRegionA ] .

abstr:VelocityFieldDEM a :Abstraction ;
    rdfs:comment "Computes velocity field from DEM." ;
    cct:expression "apply2 product (1: Field(Ratio)) (2: Field(Ratio))" ;
    :implementation multi:VelocityField ;
    :input [ a ccd:FieldRaster,
                ccd:RatioA ;
            rdfs:comment "slope" ;
            :id "1" ],
        [ a ccd:FieldRaster,
                ccd:RatioA ;
            rdfs:comment "accumulation area" ;
            :id "2" ] ;
    :output [ a ccd:FieldRaster,
                ccd:RatioA ;
            rdfs:comment "velocity" ] .

abstr:Watershed a :Abstraction ;
    rdfs:comment "Given a flow direction raster and a pour point raster, generates a watershed raster." ;
    cct:expression """
        revert (join
            (invert (2: Field(Nom)))
            (invert (apply1 reify (accumulate (1: Field(Loc)))))
        )
        """ ;
    :implementation arcgis:Watershed ;
    :input [ a ccd:FieldRaster,
                ccd:RatioA ;
            rdfs:comment "flow direction raster" ;
            :id "1" ],
        [ a ccd:FieldQ,
                ccd:PlainNominalA,
                ccd:RasterA ;
            rdfs:comment "pour point raster" ;
            :id "2" ] ;
    :output [ a ccd:FieldQ,
                ccd:PlainNominalA,
                ccd:RasterA ;
            rdfs:comment "watershed raster, gives a different watershed id for each pour point" ] .

abstr:ZonalStatisticsMeanInterval a :Abstraction ;
    rdfs:comment "Calculates the average value of a field raster within the zones of a lattice." ;
    cct:expression """
        1: Field(Itv);
        2: ObjectInfo(Nom);
        join_attr
            (get_attrL 2)
            (apply1 (fcont avg 1) (get_attrL 2))
        """ ;
    :implementation multi:ZonalStatistics ;
    :input [ a ccd:FieldRaster,
                ccd:IntervalA ;
            :id "1" ],
        [ a ccd:ObjectQ,
                ccd:VectorTessellationA ;
            :id "2" ] ;
    :output [ a ccd:IntervalA,
                ccd:ObjectQ,
                ccd:VectorTessellationA ] .

abstr:ZonalStatisticsMeanRatio a :Abstraction ;
    rdfs:comment "Calculates the average value of a field raster within the zones given by object regions. Outcome is intensive." ;
    cct:expression """
        1: Field(Ratio);
        2: ObjectInfo(Nom);
        join_attr
            (get_attrL 2)
            (groupbyR avg (join_key
                (select eq (loTopo (pi1 1) (get_attrL 2)) in)
                1
            ))
        """ ;
    :implementation multi:ZonalStatistics ;
    :input [ a ccd:FieldRaster,
                ccd:RatioA ;
            :id "1" ],
        [ a ccd:ObjectQ,
                ccd:PlainVectorRegionA ;
            :id "2" ] ;
    :output [ a ccd:IRA,
                ccd:ObjectQ,
                ccd:PlainVectorRegionA ] .

abstr:ZonalStatisticsSize a :Abstraction ;
    rdfs:comment "Measures the size of the coverage of a given field raster inside object regions." ;
    cct:expression """
        1: Field(Nom);
        2: ObjectInfo(Nom);
        join_attr
            (get_attrL 2)
            (groupbyR size (select eq (loTopo
                (fcover 1 (-: C(Nom)))
                (get_attrL 2)
            ) in))
        """ ;
    :implementation multi:ZonalStatistics ;
    :input [ a ccd:FieldRaster,
                ccd:NominalA ;
            :id "1" ],
        [ a ccd:ObjectQ,
                ccd:VectorRegionA ;
            :id "2" ] ;
    :output [ a ccd:ERA,
                ccd:ObjectQ,
                ccd:VectorRegionA ] .

abstr:ZonalStatisticsSumCount a :Abstraction ;
    rdfs:comment "Sums up count amounts (given as raster) into object regions." ;
    cct:expression """
        1: Amounts(Count);
        2: ObjectInfo(Nom);
        join_attr
            (get_attrL 2)
            (groupbyL
                sum
                (join_key (orTopo (get_attrL 2) (pi1 1)) 1)
            )
        """ ;
    :implementation multi:ZonalStatistics ;
    :input [ a ccd:ObjectQ,
                ccd:VectorRegionA ;
            :id "2" ],
        [ a ccd:AmountQ,
                ccd:CountA,
                ccd:RasterA ;
            :id "1" ] ;
    :output [ a ccd:CountA,
                ccd:ObjectQ,
                ccd:VectorRegionA ] .

abstr:con1 a :Abstraction ;
    rdfs:comment "Cuts a field raster conditional on less than some value" ;
    cct:expression "select leq (1: Field(Ratio)) (-: Ratio)" ;
    :implementation arcgis:Con ;
    :input [ a ccd:FieldRaster,
                ccd:RatioA ;
            rdfs:comment "raster" ;
            :id "1" ] ;
    :output [ a ccd:FieldRaster,
                ccd:RatioA ] .

abstr:con2 a :Abstraction ;
    rdfs:comment "Cuts a field raster conditional on (the coverage of) another field raster that is less than some value" ;
    cct:expression "subset (2: Field(Ratio)) (pi1 (select leq (1: Field(Ratio)) (-: Ratio)))" ;
    :implementation arcgis:Con ;
    :input [ a ccd:FieldRaster,
                ccd:RatioA ;
            rdfs:comment "field raster to be cut" ;
            :id "2" ],
        [ a ccd:FieldRaster,
                ccd:RatioA ;
            rdfs:comment "conditional raster, less than some value" ;
            :id "1" ] ;
    :output [ a ccd:FieldRaster,
                ccd:RatioA ] .

abstr:con3 a :Abstraction ;
    rdfs:comment "Cuts a field raster conditional on (the coverage of) another field raster, and adds another field raster for those locations outside of the coverage" ;
    cct:expression """
        1: Field(Ratio);
        2: Field(Ratio);
        3: Field(Ratio);
        set_union
            (subset 2 (pi1 (select leq 1 (-: Ratio))))
            (subset 3 (pi1 (select eq (lTopo
                (pi1 3)
                (reify (pi1 (select leq 1 (-: Ratio))))
            ) out)))
        """ ;
    :implementation arcgis:Con ;
    :input [ a ccd:FieldRaster,
                ccd:RatioA ;
            rdfs:comment "field raster to be cut for inside" ;
            :id "2" ],
        [ a ccd:FieldRaster,
                ccd:RatioA ;
            rdfs:comment "field raster to be cut for outside" ;
            :id "3" ],
        [ a ccd:FieldRaster,
                ccd:RatioA ;
            rdfs:comment "conditional raster, less than some value" ;
            :id "1" ] ;
    :output [ a ccd:FieldRaster,
                ccd:RatioA ] .

